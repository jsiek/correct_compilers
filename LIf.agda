module LIf where

open import Agda.Builtin.Unit
open import Data.Nat using (‚Ñï; zero; suc; _<_; _+_)
open import Data.Nat.Properties
open import Data.Product
open import Data.Integer using (‚Ñ§; -_; _-_; 0‚Ñ§; 1‚Ñ§; -1‚Ñ§; _‚â§·µá_)
open import Data.List
open import Data.Maybe
open import Relation.Binary.PropositionalEquality
   using (_‚â°_; refl; trans; sym; cong; cong-app)
open import Agda.Builtin.Bool renaming (Bool to ùîπ)
open import Data.Bool using (_‚àß_; _‚à®_; not)
open import Reader
open import Utilities

----------------- Definition of LIf ----------------------------

data UniOp : Set where
  Neg : UniOp
  Not : UniOp

data BinOp : Set where
  Sub : BinOp
  Eq : BinOp
  LessEq : BinOp
  And : BinOp

data Exp : Set where
  Num : ‚Ñ§ ‚Üí Exp
  Bool : ùîπ ‚Üí Exp
  Read : Exp
  Uni : UniOp ‚Üí Exp ‚Üí Exp
  Bin : BinOp ‚Üí Exp ‚Üí Exp ‚Üí Exp
  Var : (i : Id) ‚Üí Exp
  Let : Exp ‚Üí Exp ‚Üí Exp
  If : Exp ‚Üí Exp ‚Üí Exp ‚Üí Exp

data Value : Set where
  Int : ‚Ñ§ ‚Üí Value
  Bool : ùîπ ‚Üí Value

toInt : Value ‚Üí Maybe ‚Ñ§
toInt (Int n) = just n
toInt (Bool b) = nothing

toBool : Value ‚Üí Maybe ùîπ
toBool (Int n) = nothing
toBool (Bool b) = just b

uniop : UniOp ‚Üí Value ‚Üí Reader Value
uniop Neg v =
  try (toInt v) then
  (Œª n ‚Üí return (Int (- n)))
uniop Not v =
  try (toBool v) then
  (Œª n ‚Üí return (Bool (not n)))

binop : BinOp ‚Üí Value ‚Üí Value ‚Üí Reader Value
binop Sub v‚ÇÅ v‚ÇÇ =
  try (toInt v‚ÇÅ) then
  Œª n‚ÇÅ ‚Üí try (toInt v‚ÇÇ) then
  Œª n‚ÇÇ ‚Üí return (Int (n‚ÇÅ - n‚ÇÇ))
binop Eq v‚ÇÅ v‚ÇÇ =
  try (toInt v‚ÇÅ) then
  Œª n‚ÇÅ ‚Üí try (toInt v‚ÇÇ) then
  Œª n‚ÇÇ ‚Üí return (Bool ((n‚ÇÅ ‚â§·µá n‚ÇÇ) ‚àß (n‚ÇÇ ‚â§·µá n‚ÇÅ)))
binop LessEq v‚ÇÅ v‚ÇÇ =
  try (toInt v‚ÇÅ) then
  Œª n‚ÇÅ ‚Üí try (toInt v‚ÇÇ) then
  Œª n‚ÇÇ ‚Üí return (Bool (n‚ÇÅ ‚â§·µá n‚ÇÇ))
binop And v‚ÇÅ v‚ÇÇ =
  try (toBool v‚ÇÅ) then
  Œª b‚ÇÅ ‚Üí try (toBool v‚ÇÇ) then
  Œª b‚ÇÇ ‚Üí return (Bool (b‚ÇÅ ‚àß b‚ÇÇ))

interp-exp : Exp ‚Üí Env Value ‚Üí Reader Value
interp-exp (Num n) œÅ = return (Int n)
interp-exp (Bool b) œÅ = return (Bool b)
interp-exp Read œÅ = read-int Int
interp-exp (Uni op e) œÅ =
  (interp-exp e œÅ) then
  Œª v ‚Üí uniop op v
interp-exp (Bin op e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí (interp-exp e‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí binop op v‚ÇÅ v‚ÇÇ
interp-exp (Var i) œÅ = try (nth œÅ i)
interp-exp (Let e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí interp-exp e‚ÇÇ (v‚ÇÅ ‚à∑ œÅ)
interp-exp (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí try (toBool v‚ÇÅ) then
  Œª { true ‚Üí interp-exp e‚ÇÇ œÅ
    ; false ‚Üí interp-exp e‚ÇÉ œÅ }

interp-LIf : Exp ‚Üí Inputs ‚Üí Maybe Value
interp-LIf e s = run (interp-exp e []) s

----------------- Definition of LMonIf ----------------------------

data Atm : Set where
  Num : ‚Ñ§ ‚Üí Atm 
  Bool : ùîπ ‚Üí Atm
  Var : Id ‚Üí Atm

data Mon : Set where
  Atom : Atm ‚Üí Mon
  Read : Mon
  Uni : UniOp ‚Üí Atm ‚Üí Mon
  Bin : BinOp ‚Üí Atm ‚Üí Atm ‚Üí Mon
  Let : Mon ‚Üí Mon ‚Üí Mon
  If : Mon ‚Üí Mon ‚Üí Mon ‚Üí Mon

interp-atm : Atm ‚Üí Env Value ‚Üí Maybe Value
interp-atm (Num n) œÅ = just (Int n)
interp-atm (Bool b) œÅ = just (Bool b)
interp-atm (Var i) œÅ = nth œÅ i

interp-mon : Mon ‚Üí Env Value ‚Üí Reader Value
interp-mon (Atom atm) œÅ = try (interp-atm atm œÅ)
interp-mon Read œÅ = read-int Int
interp-mon (Uni op a) œÅ =
  try (interp-atm a œÅ) then
  Œª v ‚Üí uniop op v
interp-mon (Bin op a‚ÇÅ a‚ÇÇ) œÅ =
  try (interp-atm a‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí binop op v‚ÇÅ v‚ÇÇ
interp-mon (Let e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-mon e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí interp-mon e‚ÇÇ (v‚ÇÅ ‚à∑ œÅ)
interp-mon (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) œÅ =
  (interp-mon e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí try (toBool v‚ÇÅ) then
  Œª { true ‚Üí interp-mon e‚ÇÇ œÅ
    ; false ‚Üí interp-mon e‚ÇÉ œÅ }

interp-LMonIf : Mon ‚Üí Inputs ‚Üí Maybe Value
interp-LMonIf m s = run (interp-mon m []) s

shift-atm : Atm ‚Üí ‚Ñï ‚Üí Atm
shift-atm (Num n) c = Num n
shift-atm (Bool b) c = Bool b
shift-atm (Var x) c = Var (shift-var x c)

shift-mon : Mon ‚Üí ‚Ñï ‚Üí Mon
shift-mon (Atom atm) c = Atom (shift-atm atm c)
shift-mon Read c = Read
shift-mon (Uni op a) c = Uni op (shift-atm a c)
shift-mon (Bin op a‚ÇÅ a‚ÇÇ) c = Bin op (shift-atm a‚ÇÅ c) (shift-atm a‚ÇÇ c)
shift-mon (Let m‚ÇÅ m‚ÇÇ) c =
  Let (shift-mon m‚ÇÅ c) (shift-mon m‚ÇÇ (suc c))
shift-mon (If m‚ÇÅ m‚ÇÇ m‚ÇÉ) c =
  If (shift-mon m‚ÇÅ c) (shift-mon m‚ÇÇ c) (shift-mon m‚ÇÉ c)

----------------- Remove Complex Operands ----------------------------

rco : Exp ‚Üí Mon
rco (Num n) = Atom (Num n)
rco (Bool b) = Atom (Bool b)
rco Read = Read
rco (Uni op e) =
   Let (rco e) (Uni op (Var zero))
rco (Bin op e‚ÇÅ e‚ÇÇ) =
   Let (rco e‚ÇÅ)
   (Let (shift-mon (rco e‚ÇÇ) zero) (Bin op (Var (suc (zero))) (Var zero)))
rco (Var i) = Atom (Var i)
rco (Let e‚ÇÅ e‚ÇÇ) = Let (rco e‚ÇÅ) (rco e‚ÇÇ)
rco (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) = If (rco e‚ÇÅ) (rco e‚ÇÇ) (rco e‚ÇÉ)


----------------- Definition of IL1If ----------------------------

data IL1-Exp : Set where
  Atom : Atm ‚Üí IL1-Exp
  Read : IL1-Exp
  Uni : UniOp ‚Üí Atm ‚Üí IL1-Exp
  Bin : BinOp ‚Üí Atm ‚Üí Atm ‚Üí IL1-Exp
  Assign : Id ‚Üí IL1-Exp ‚Üí IL1-Exp ‚Üí IL1-Exp
  If : IL1-Exp ‚Üí IL1-Exp ‚Üí IL1-Exp ‚Üí IL1-Exp

data IL1-Prog : Set where
  Program : ‚Ñï ‚Üí IL1-Exp ‚Üí IL1-Prog

interp-il1-exp : IL1-Exp ‚Üí Env Value ‚Üí Reader Value
interp-il1-exp (Atom atm) œÅ = try (interp-atm atm œÅ)
interp-il1-exp Read œÅ = read-int Int
interp-il1-exp (Uni op a) œÅ =
  try (interp-atm a œÅ) then
  Œª v ‚Üí uniop op v
interp-il1-exp (Bin op a‚ÇÅ a‚ÇÇ) œÅ =
  try (interp-atm a‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí binop op v‚ÇÅ v‚ÇÇ
interp-il1-exp (Assign x e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-il1-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí interp-il1-exp e‚ÇÇ (update œÅ x v‚ÇÅ)
interp-il1-exp (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) œÅ =
  (interp-il1-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí try (toBool v‚ÇÅ) then
  Œª { true ‚Üí interp-il1-exp e‚ÇÇ œÅ
    ; false ‚Üí interp-il1-exp e‚ÇÉ œÅ }

interp-IL1 : IL1-Prog ‚Üí Inputs ‚Üí Maybe Value
interp-IL1 (Program n e) s =
    run (interp-il1-exp e (replicate n (Int 0‚Ñ§))) s

----------------- Convert to IL1: Lift Locals -------------------

shifts-atm : Atm ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Atm
shifts-atm (Num x) c n = Num x
shifts-atm (Bool b) c n = Bool b
shifts-atm (Var x) c n = Var (shifts-var x c n)

shifts-il1-exp : IL1-Exp ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí IL1-Exp
shifts-il1-exp (Atom a) c n =
    Atom (shifts-atm a c n) 
shifts-il1-exp Read c n =
    Read
shifts-il1-exp (Uni op a) c n =
    Uni op (shifts-atm a c n)
shifts-il1-exp (Bin op a‚ÇÅ a‚ÇÇ) c n =
    Bin op (shifts-atm a‚ÇÅ c n) (shifts-atm a‚ÇÇ c n)
shifts-il1-exp (Assign x e‚ÇÅ e‚ÇÇ) c n =
    Assign (shifts-var x c n) (shifts-il1-exp e‚ÇÅ c n) (shifts-il1-exp e‚ÇÇ c n)
shifts-il1-exp (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) c n =
    If (shifts-il1-exp e‚ÇÅ c n) (shifts-il1-exp e‚ÇÇ c n) (shifts-il1-exp e‚ÇÉ c n)

-- Hoists all the Let's to the top, leaving in their place assignments.
--   let x = e‚ÇÅ in e‚ÇÇ
--   ==>
--   let x = 0 in { x := e‚Ä≤‚ÇÅ; e‚Ä≤‚ÇÇ }
--
--
--   Returns the number of let's around the expression:
--   let y‚ÇÅ=0,...,y·µ¢=0 in m‚ÇÅ
--   is represented as
--   i , m‚ÇÅ
lift-locals-mon : Mon ‚Üí ‚Ñï √ó IL1-Exp
lift-locals-mon (Atom a) = 0 , (Atom a)
lift-locals-mon Read = 0 , Read
lift-locals-mon (Uni op a) = 0 , (Uni op a)
lift-locals-mon (Bin op a‚ÇÅ a‚ÇÇ) = 0 , (Bin op a‚ÇÅ a‚ÇÇ)

lift-locals-mon (Let m‚ÇÅ m‚ÇÇ)
    with lift-locals-mon m‚ÇÅ
... | i , e‚ÇÅ
    with lift-locals-mon m‚ÇÇ
... | j , e‚ÇÇ
--   let x = (let y‚ÇÅ=0,...,y·µ¢=0 in m‚ÇÅ)
--   in (let z‚ÇÅ=0,...,z‚±º=0 in m‚ÇÇ)
--   ==>
--   let x=0, y‚ÇÅ=0,...,y·µ¢=0, z‚ÇÅ=0,...,z‚±º=0  in
--   i+j := (e‚ÇÅ ‚Üë j+1 cutoff 0);
--   (e‚ÇÇ ‚Üë i cutoff j)
    = (suc (i + j)) , Assign (i + j) (shifts-il1-exp e‚ÇÅ 0 (suc j)) (shifts-il1-exp e‚ÇÇ j i)
    
lift-locals-mon (If m‚ÇÅ m‚ÇÇ m‚ÇÉ) 
    with lift-locals-mon m‚ÇÅ 
... | i , e‚ÇÅ
    with lift-locals-mon m‚ÇÇ 
... | j , e‚ÇÇ
    with lift-locals-mon m‚ÇÉ 
... | k , e‚ÇÉ
--  if (let x‚ÇÅ=0,...,x·µ¢=0 in m‚ÇÅ) then
--      (let y‚ÇÅ=0,...,y‚±º=0 in m‚ÇÇ)
--  else 
--      (let z‚ÇÅ=0,...,z_k=0 in m‚ÇÉ)
--  ==>
--  let x‚ÇÅ=0,...,x·µ¢=0, y‚ÇÅ=0,...,y‚±º=0, z‚ÇÅ=0,...,z_k=0 in
--  if (m‚ÇÅ ‚Üë j + k cutoff 0) then ((m‚ÇÇ ‚Üë k cutoff 0) ‚Üë i cutoff (k + j)) else (m‚ÇÉ ‚Üë i + j cutoff k)
    =
    let e‚Ä≤‚ÇÅ = shifts-il1-exp e‚ÇÅ 0 (j + k) in
    let e‚Ä≤‚ÇÇ = shifts-il1-exp (shifts-il1-exp e‚ÇÇ 0 k) (k + j) i in
    let e‚Ä≤‚ÇÉ = shifts-il1-exp e‚ÇÉ k (i + j) in
    (i + j + k) , (If e‚Ä≤‚ÇÅ e‚Ä≤‚ÇÇ e‚Ä≤‚ÇÉ)

lift-locals : Mon ‚Üí IL1-Prog
lift-locals m
    with lift-locals-mon m
... | n , e = Program n e    

---- Test lift-locals

S0 : Inputs
S0 = (1 , Œª x ‚Üí Data.Integer.+ x)

test : Mon ‚Üí Set
test P = interp-IL1 (lift-locals P) S0 ‚â° run (interp-mon P []) S0

P0 : Mon
P0 = Let Read (Atom (Var 0))
T0 : test P0
T0 = refl

P1 : Mon
P1 = Let Read (Let Read (Bin Sub (Var 0) (Var 1)))
T1 : test P1
T1 = refl

P2 : Mon
P2 = Let Read
      (Let (Let (Bin Sub (Var 0) (Num 1‚Ñ§)) (Bin Sub (Var 0) (Num -1‚Ñ§)))
       (Let (Uni Neg (Var 0))
        (Bin Sub (Var 2) (Var 0))))
T2 : test P2
T2 = refl

P3 : Mon
P3 = Let Read
      (If (Bin LessEq (Var 0) (Num 1‚Ñ§))
        (Let Read (Atom (Var 0)))
        (Let Read (Atom (Num 0‚Ñ§))))
T3 : test P3
T3 = refl

P4 : Mon
P4 = Let Read
       (If (Let Read (Bin LessEq (Var 0) (Num 1‚Ñ§)))
           (Let Read (Bin Sub (Var 0) (Var 1)))
           (Let Read (Bin Sub (Var 1) (Var 0))))
T4 : test P4
T4 = refl

----------------- Definition of CIf ----------------------------

data CExp : Set where
  Atom : Atm ‚Üí CExp
  Read : CExp
  Uni : UniOp ‚Üí Atm ‚Üí CExp
  Bin : BinOp ‚Üí Atm ‚Üí Atm ‚Üí CExp

data CTail : Set where
  Return : CExp ‚Üí CTail
  Assign : Id ‚Üí CExp ‚Üí CTail ‚Üí CTail
  If : BinOp ‚Üí Atm ‚Üí Atm ‚Üí Id ‚Üí Id ‚Üí CTail
  Goto : Id ‚Üí CTail

Blocks : Set
Blocks = List CTail

data Type : Set where
  IntT : Type
  BoolT : Type

data C-Prog : Set where
  Program : ‚Ñï ‚Üí Id ‚Üí Blocks ‚Üí C-Prog

--- Interpreter for CIf

interp-CExp : CExp ‚Üí Env Value ‚Üí Reader Value
interp-CExp (Atom atm) œÅ = try (interp-atm atm œÅ)
interp-CExp Read œÅ = read-int Int
interp-CExp (Uni op a) œÅ =
  try (interp-atm a œÅ) then
  Œª v ‚Üí uniop op v
interp-CExp (Bin op a‚ÇÅ a‚ÇÇ) œÅ =
  try (interp-atm a‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí binop op v‚ÇÅ v‚ÇÇ

--- Big-step Semantics for CIf

infix 4 _,_,_‚ä¢_‚áì_
data _,_,_‚ä¢_‚áì_ : Env Value ‚Üí Inputs ‚Üí Blocks ‚Üí CTail ‚Üí (Value √ó Inputs) ‚Üí Set where
   return-‚áì : ‚àÄ{œÅ}{s}{B}{e}{r}
       ‚Üí interp-CExp e œÅ s ‚â° just r
       ‚Üí œÅ , s , B ‚ä¢ Return e ‚áì r
   assign-‚áì : ‚àÄ{œÅ}{B}{x}{e}{t}{s0 s1 : Inputs}{v}{r : (Value √ó Inputs)}
       ‚Üí interp-CExp e œÅ s0 ‚â° just (v , s1)
       ‚Üí update œÅ x v , s1 , B ‚ä¢ t ‚áì r
       ‚Üí œÅ , s0 , B ‚ä¢ Assign x e t ‚áì r
   if-‚áì-true : ‚àÄ{œÅ}{B}{op}{a‚ÇÅ a‚ÇÇ : Atm}{thn}{els}{s0 s1 : Inputs}{t-thn : CTail }{r : (Value √ó Inputs)}
       ‚Üí interp-CExp (Bin op a‚ÇÅ a‚ÇÇ) œÅ s0 ‚â° just (Bool true , s1)
       ‚Üí nth B thn ‚â° just t-thn
       ‚Üí œÅ , s1 , B ‚ä¢ t-thn ‚áì r
       ‚Üí œÅ , s0 , B ‚ä¢ If op a‚ÇÅ a‚ÇÇ thn els ‚áì r
   if-‚áì-false : ‚àÄ{œÅ}{B}{op}{a‚ÇÅ a‚ÇÇ : Atm}{thn}{els}{s0 s1 : Inputs}{t-els : CTail }{r : (Value √ó Inputs)}
       ‚Üí interp-CExp (Bin op a‚ÇÅ a‚ÇÇ) œÅ s0 ‚â° just (Bool true , s1)
       ‚Üí nth B els ‚â° just t-els
       ‚Üí œÅ , s1 , B ‚ä¢ t-els ‚áì r
       ‚Üí œÅ , s0 , B ‚ä¢ If op a‚ÇÅ a‚ÇÇ thn els ‚áì r
   goto-‚áì : ‚àÄ{œÅ}{B}{s0 : Inputs}{lbl}{t : CTail}{r : (Value √ó Inputs)}
       ‚Üí nth B lbl ‚â° just t
       ‚Üí œÅ , s0 , B ‚ä¢ t ‚áì r
       ‚Üí œÅ , s0 , B ‚ä¢ Goto lbl ‚áì r

eval-CIf : C-Prog ‚Üí Inputs ‚Üí Value ‚Üí Set
eval-CIf (Program n lbl B) s v =
    Œ£[ s' ‚àà Inputs ] (replicate n (Int 0‚Ñ§)) , s , B ‚ä¢ Goto lbl ‚áì (v , s')

----------------- Explicate Control ----------------------------

-- Split into two parts:
-- A) Move the Let's to the top
-- B) Convert AST to a DAG

-- Block Monad
-- Next label to use for a new block
-- The list of blocks that have been created

Blocker : Set ‚Üí Set
Blocker A = Blocks ‚Üí A √ó Blocks

returnB : ‚àÄ{A : Set} ‚Üí A ‚Üí Blocker A
returnB a s = a , s

_thenB_ : ‚àÄ{A B : Set} ‚Üí Blocker A ‚Üí (A ‚Üí Blocker B) ‚Üí Blocker B
(M thenB g) s
    with M s
... | (v , s') = g v s'

create-block : CTail ‚Üí Blocker Id
create-block (Goto lbl) B = lbl , B
create-block t B = length B , (B ++ [ t ])

explicate-assign : Id ‚Üí IL1-Exp ‚Üí CTail ‚Üí Blocker CTail
explicate-pred : IL1-Exp ‚Üí CTail ‚Üí CTail ‚Üí Blocker CTail
explicate-tail : IL1-Exp ‚Üí Blocker CTail

explicate-assign y (Atom a) rest = returnB (Assign y (Atom a) rest)
explicate-assign y Read rest = returnB (Assign y Read rest)
explicate-assign y (Uni op a) rest = returnB (Assign y (Uni op a) rest)
explicate-assign y (Bin op a‚ÇÅ a‚ÇÇ) rest = returnB (Assign y (Bin op a‚ÇÅ a‚ÇÇ) rest)
explicate-assign y (Assign x e‚ÇÅ e‚ÇÇ) rest =
  explicate-assign y e‚ÇÇ rest thenB
  Œª t‚ÇÇ ‚Üí explicate-assign x e‚ÇÅ t‚ÇÇ
explicate-assign y (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) rest =
   create-block rest thenB
   Œª l ‚Üí explicate-assign y e‚ÇÇ (Goto l) thenB
   Œª t‚ÇÇ ‚Üí explicate-assign y e‚ÇÉ (Goto l) thenB
   Œª t‚ÇÉ ‚Üí explicate-pred e‚ÇÅ t‚ÇÇ t‚ÇÉ

explicate-pred (Atom a) thn els =
  create-block thn thenB
  Œª l‚ÇÅ ‚Üí create-block els thenB
  Œª l‚ÇÇ ‚Üí returnB (If Eq a (Bool true) l‚ÇÅ l‚ÇÇ)
explicate-pred Read thn els = returnB (Return (Atom (Num 0‚Ñ§)))
explicate-pred (Uni Neg a) thn els = returnB (Return (Atom (Num 0‚Ñ§)))
explicate-pred (Uni Not a) thn els = explicate-pred (Atom a) els thn
explicate-pred (Bin op a‚ÇÅ a‚ÇÇ) thn els =
  create-block thn thenB
  Œª lbl-thn ‚Üí create-block els thenB
  Œª lbl-els ‚Üí returnB (If op a‚ÇÅ a‚ÇÇ lbl-thn lbl-els)
explicate-pred (Assign x e‚ÇÅ e‚ÇÇ) thn els =
  explicate-pred e‚ÇÇ thn els thenB
  Œª rest' ‚Üí explicate-assign x e‚ÇÅ rest'
explicate-pred (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) thn els =
    create-block thn thenB
   Œª lbl-thn ‚Üí create-block els thenB
   Œª lbl-els ‚Üí explicate-pred e‚ÇÇ (Goto lbl-thn) (Goto lbl-els) thenB
   Œª t‚ÇÇ ‚Üí (explicate-pred e‚ÇÉ (Goto lbl-thn) (Goto lbl-els)) thenB
   Œª t‚ÇÉ ‚Üí explicate-pred e‚ÇÅ t‚ÇÇ t‚ÇÉ

explicate-tail (Atom a) = returnB (Return (Atom a))
explicate-tail Read = returnB (Return Read)
explicate-tail (Uni op a) = returnB (Return (Uni op a))
explicate-tail (Bin op a‚ÇÅ a‚ÇÇ) = returnB (Return (Bin op a‚ÇÅ a‚ÇÇ))
explicate-tail (Assign x e‚ÇÅ e‚ÇÇ) =
  explicate-tail e‚ÇÇ thenB
  Œª t‚ÇÇ ‚Üí explicate-assign x e‚ÇÅ t‚ÇÇ
explicate-tail (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) =
  (explicate-tail e‚ÇÇ) thenB
  Œª t‚ÇÇ ‚Üí (explicate-tail e‚ÇÉ) thenB
  Œª t‚ÇÉ ‚Üí explicate-pred e‚ÇÅ t‚ÇÇ t‚ÇÉ

explicate : IL1-Prog ‚Üí C-Prog
explicate (Program n e)
    with ((explicate-tail e) thenB
          (Œª t ‚Üí create-block t)) []
... | lbl , B = Program n lbl B
     
