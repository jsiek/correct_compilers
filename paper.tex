%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,proceedings,bibtex,sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[sigplan,review,dvipsnames,screen,10pt]{acmart}
%\documentclass[sigplan,screen]{acmart}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[OlivierFest '25]{Workshop dedicated to Olivier Danvy's 65th birthday}{October,
  2025}{Singapore}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{url}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{stmaryrd}
%\usepackage[none]{hyphenat}

\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}

%\usepackage[verbose]{newunicodechar}
%% \newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}~}}
%% \newunicodechar{ùîπ}{\ensuremath{\mathbb{B}~}}
%\newunicodechar{‚Ñ§}{\ensuremath{\mathbb{Z}~}}
%\newunicodechar{‚Üí}{\ensuremath{~\to~}}
%\newunicodechar{√ó}{\ensuremath{~\times~}}

\newcommand{\LangIf}{$\Lang_{\mathsf{If}}$} %R2
\newcommand{\RCO}{\mathit{mon}} % output of remove-complex-opera*
\newcommand{\LangIfANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{if}}}} %R2
\newcommand{\CLang}{\mathcal{C}}
\newcommand{\LangCIf}{$\CLang_{\mathsf{If}}$} %C1

\newcommand{\TRUE}[0]{\mathsf{true}}
\newcommand{\FALSE}[0]{\mathsf{false}}
\newcommand{\IF}[3]{\mathsf{if}\,#1\,\mathsf{then}\,#2\,\mathsf{else}\,#3}

\newcommand{\CE}[1]{\mathcal{E} \llbracket #1 \rrbracket}
\newcommand{\CB}[3]{\mathcal{B} \llbracket #1 \rrbracket ( #2, #3 )}

\lstset{%
language=Python,
basicstyle=\ttfamily\small,
keywordstyle=\ttfamily\small,
%morekeywords={match,case,bool,int,let,begin,if,else,closure},
%deletekeywords={locals},
escapechar=|,
mathescape=true,
columns=flexible,
%moredelim=[is][\color{red}]{~}{~},
showstringspaces=false,
%inputencoding=utf8
literate={‚Üí}{{\to}}1,
}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Verified Nanopasses for Compiling Conditionals}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Jeremy G. Siek}
%\authornote{Both authors contributed equally to this research.}
\email{jsiek@iu.edu}
%\orcid{1234-5678-9012}
%% \author{G.K.M. Tobin}
%% \authornotemark[1]
%% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{Indiana University}
  \city{Bloomington}
  \state{IN}
  \country{USA}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato et al.}

\begin{abstract}
We present a proof of correctness in Agda for four nanopasses that
translate a source language with let binding, integer arithmetic,
conditional expressions and Booleans into an x86-flavored register
transfer language. The most interesting of these four nanopasses is a
translation of conditional expressions into goto-style control flow
that uses the continuation-oriented approach of Olivier Danvy's
one-pass transformation into monadic normal form (2003).
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%% \begin{CCSXML}
%% <ccs2012>
%%  <concept>
%%   <concept_id>00000000.0000000.0000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>500</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>00000000.00000000.00000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>300</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>00000000.00000000.00000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>00000000.00000000.00000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%% </ccs2012>
%% \end{CCSXML}

%% \ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%% \ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%% \ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%% \ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{short-cut boolean evaluation, nanopass, verified compilation, mechanized proof, Agda}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
%% \begin{teaserfigure}
%%   \includegraphics[width=\textwidth]{sampleteaser}
%%   \caption{Seattle Mariners at Spring Training, 2010.}
%%   \Description{Enjoying the baseball game from the third-base
%%   seats. Ichiro Suzuki preparing to bat.}
%%   \label{fig:teaser}
%% \end{teaserfigure}

%% \received{20 February 2007}
%% \received[revised]{12 March 2009}
%% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

The compilation of Boolean expressions and conditionals is a classic
topic in the compiler literature, going back to an algorithm of
\citet{Aho:1986qf} (presented in the form of an attribute grammar)
that translates Boolean expressions and conditionals into gotos. The
compilation of Boolean expressions and conditionals often occurs at an
interesting stage in the compilation pipeline, where the intermediate
language changes from an abstract syntax \emph{tree} into a control
flow \emph{graph}, or equivalently, an intermediate language with
\texttt{goto}. Further, when targeting an assembly language such as
Intel's x86, the naive approach to compiling boolean expressions and
conditionals produces embarrassingly inefficient code. Similar issues
arise in the compilation of languages such as Haskell, where the
case-of-case transformation is employed to optimize dispatching on
algebraic datatypes~\citep{PEYTONJONES19983}.

Olivier Danvy, in his paper \emph{A New One-Pass Transformation into
Monadic Normal Form}~\citep{Danvy:2003fk}, presents an elegant family
of structurally recursive functions that translate Boolean expressions
and conditionals into a monadic normal form that (1) no longer
contains Boolean expressions, (2) the condition expression of a
condition is a value, and (3) jumps are expressed using zero-arity
function calls. One of the key parts of that translation is in the
compilation of a conditional expression such as $(\IF{b}{e_1}{e_2})$,
where the expression $b$ is compiled using a special function
$\mathcal{B}$ that takes two more arguments, the generated code for
the two branches, that is, for the two continuations of $b$. Thus,
$\mathcal{B}$ can analyze the expression $b$ to decide how to generate
code for the $\mathsf{if}$, or whether an $\mathsf{if}$ is even
necessary.
\[
\CE{\IF{b}{e_1}{e_2}} = \CB{b}{\CE{e_1}}{\CE{e_2}}
\]
For example, in the simple cases where $b$ is $\TRUE$ or $\FALSE$,
no branching is needed.
\begin{align*}
\CB{\TRUE}{c_1}{c_2} &= c_1 \\
\CB{\FALSE}{c_1}{c_2} &= c_2
\end{align*}
\noindent This idea builds on earlier work by \citet{Lawall:1994aa} on
continuation-based partial evaluation. Indeed, the above is a partial
evaluation of Boolean expressions.

My first exposure to these ideas was in Kent Dybvig's compiler
course~\citep{Dybvig:2010aa} where he taught the techniques used in
the Chez Scheme compiler~\citep{Dybvig:2006aa}.  One of those
techniques is called destination-driven code
generation~\citep{Dybvig:1990aa}, which adds an extra parameter to the
compilation function to indicate how the context will use the result
value of an expression. The context may (1) ignore the result (and
only care about the expression's side effects), (2) branch based on
interpreting its result as a boolean, (3) assign the result to a
variable, or (4) output the result. These options are encoded as a
disjoint union.  Relating this to Olivier's transformation functions,
the $\mathcal{E}$ function is for contexts that need the actual value
and the $\mathcal{B}$ function is for contexts that branch on the
expression's result. Of course, a pair of functions is isomorphic to a
function on a disjoint union.
\[
(A ‚Üí C) √ó (B ‚Üí C) ‚âÖ (A + B) ‚Üí C
\]

The CompCert compiler \citep{Leroy:2006fe} (a compiler for C verified
in Rocq) uses the one-function per context approach of Danvy in the
RTLgen pass that translates from the CminorSel intermediate language
to CompCert's register transfer language. The verified CakeML
compiler, on the other hand, employs a naive translation of Boolean
expressions and conditionals for the compilation of stackLang into
labLang~\citep{Kumar:2014aa}.

Towards developing a course on verified compilation, I am interested
in proving correctness of the compiler presented in the
\emph{Essentials of Compilation}
textbook~\citep{Siek:2023tr,Siek:2023ue}. While it does not include
proofs of correctness for its compiler passes, the textbook is
organized in a way that might facilitate the proofs of correctness.
%
\emph{Essentials of Compilation} takes an \emph{incremental} approach
to teaching compilers, that is, it guides the students through the
creation of multiple compilers for a sequence of languages, each of
which adds a language feature to the previous language. For the
language with Boolean expressions and conditionals, the Explicate
Control pass of the compiler uses the one-function per context
approach of Danvy to translate into an x86-flavored register transfer
language.
%
In addition to being incremental, \emph{Essentials of Compilation}
employs the \emph{nanopass} approach, breaking up the compiler into
many small passes that are easier for students to
digest~\citep{Sarkar:2004fk}.
%
There are many other pedogogical treatments of
compilation~\citep{Appel:2003fk,Sumii:2005aa,Aho:2006wb,Cooper:2011aa,Grune:2012aa}
but none of them take the incremental approach.

This paper presents a proof of correctness in Agda for four nanopasses
that translate a source language with let binding, integer arithmetic,
conditional expressions and Booleans into an x86-flavored register
transfer language. The Agda code is available in the supplementary
material and at the following location.
\begin{center}
\url{https://github.com/jsiek/correct_compilers}
\end{center}
The Agda code does not depend on special features of Agda and could
have been carried out in Rocq, Isabelle, or Lean.\footnote{The choice
of Agda for this paper is not an endorsement of Agda but is a
byproduct of the author's relative expertise in Agda at the time of
writing.}

The four compiler passes presented here correspond to the
following three passes in \emph{Essentials of Compilation}:
\begin{enumerate}
\item Remove Complex Operands
\item Explicate Control
\item Select Instructions
\end{enumerate}
The process of proving correctness of the Explicate Control pass
made it clear to me that it has two distinct responsibilities that
deserve to be separated:
\begin{itemize}
\item Replacing \texttt{let} expressions with assignment statements.
\item Translating Boolean expressions and conditionals into
  \texttt{goto}-based control-flow.
\end{itemize}
(The RTLgen pass of CompCert also handles the above two
responsibilities.)  So in this paper, the Explicate Control pass is
split into two passes, the first named Lift Locals and the second that
keeps the name Explicate Control.
\begin{enumerate}
\item Remove Complex Operands
\item Lift Locals
\item Explicate Control
\item Select Instructions
\end{enumerate}
In compilers that do not take the nanopass approach, unrelated
responsibilities are sometimes combined into the same pass.  For
example, \citet{Sumii:2005aa} combines the first three of the above
passes into a single pass.

Section~\ref{sec:langs} of the paper introduces the intermediate
languages. Section~\ref{sec:compiler} describes the compiler,
detailing each pass and the proof of
correctness. Section~\ref{sec:conclusion} concludes the paper.

\section{The Languages}
\label{sec:langs}

In this section we describe how we formalize the syntax and semantics
of the source language and four intermediate languages in Agda:
\begin{enumerate}
\item Integers, Booleans, \texttt{let}, and \texttt{if}
\item Monadic Normal Form
\item Imperative with Structured Control Flow
\item A C-like language with \emph{goto}
\item X86 assembly but with variables
\end{enumerate}
These languages and their semantics are quite standard. However, there
are many other intermediate languages in the literature to choose
from~\citep{Flanagan:1993cg,Hatcliff:1994vn,Kelsey:1995uq,Birkedal:1996aa},
so why these languages, and why this order?  The answer is that they
happen to represent the images of the four nanopasses.  So then the
next question is: why do we order the nanopasses this way? The main
thing to consider is that some passes make later passes easier because
they remove a language feature that would have been complicated to
handle. For example, the Lift Locals pass removes \texttt{let}, and I
found \texttt{let} difficult to deal with in the proof of correctness
for Explicate Control. The other thing to consider is that some
compiler passes use certain language features in their generated code,
so the passes that remove those language features better come later in
the ordering.  For example, the Closure Conversion pass (not discussed
here) generates code with \texttt{let}, so Closure Conversion comes
before Lift Locals. Finally, many design choices in \emph{Essentials
of Compilation} have been inherited from \citet{Dybvig:2010aa}

One of the perennial challenges of formalizing semantics in a proof
assistant is that one needs to choose a representation of variables.
Of the many options, my current favorite is good old de Bruijn
indices~\citep{Bruijn:1972kx}.  Thus, identifiers \lstinline{Id} are
represented as natural numbers.
\begin{lstlisting}
Id = $‚Ñï$
\end{lstlisting}

\subsection{The Source Language}

The source language includes integers, Booleans, \texttt{Let} binding,
and conditional expressions. We choose two representative primitive
operators: \texttt{Sub} for integer subtraction and \texttt{Eq} for
equality on integers and Booleans.\footnote{Adding more primitive
operators is straightforward but uninteresting.}  The \texttt{Read}
operation requests an integer input from the user of the
program.\footnote{\texttt{Read} is necessary to prevent students from
interpreting the programs instead of compiling them.}

\begin{lstlisting}
data Exp : Set where
  Num : $‚Ñ§$ $‚Üí$ Exp
  Bool : $ùîπ$ $‚Üí$ Exp
  Read : Exp
  Sub : Exp $‚Üí$ Exp $‚Üí$ Exp
  Eq : Exp $‚Üí$ Exp $‚Üí$ Exp
  Var : Id $‚Üí$ Exp
  Let : Exp $‚Üí$ Exp $‚Üí$ Exp
  If : Exp $‚Üí$ Exp $‚Üí$ Exp $‚Üí$ Exp
\end{lstlisting}

Towards specifying the semantics of this language, the inputs to the
program are an infinite stream of integers represented as a natural
number and a function from the naturals to the integers.  The natural
number is incremented each time the program reads an input.

\begin{lstlisting}
Inputs = $‚Ñï$ $√ó$ ($‚Ñï$ $‚Üí$ $‚Ñ§$)
\end{lstlisting}

The following monad is used to thread the inputs through the
interpreter and to account for partiality via \lstinline{Maybe}
(e.g. looking up an undefined variable).

\begin{lstlisting}
Reader A = Inputs $‚Üí$ Maybe (A $√ó$ Inputs)
\end{lstlisting}

\noindent The result of an expression is an integer or Boolean, for which we
define the \lstinline{Value} type.

\begin{lstlisting}
data Value : Set where
  Int : $‚Ñ§$ $‚Üí$ Value
  Bool : $ùîπ$ $‚Üí$ Value
\end{lstlisting}

\noindent The variables (de Bruijn indices) are interpreted using an
environment that is represented as a list of values.

\begin{lstlisting}
Env A = List A
\end{lstlisting}

\noindent The semantics of expressions is given by the
\lstinline{interp-exp} function, which maps an expression and
environment to a value, in our \lstinline{Reader} monad.

\begin{lstlisting}
interp-exp : Exp $‚Üí$ Env Value $‚Üí$ Reader Value
\end{lstlisting}

\noindent The semantics of a whole program is given by the
\lstinline{interp-LIf} function.

\begin{lstlisting}
interp-LIf : Exp $‚Üí$ Inputs $‚Üí$ Maybe Value
\end{lstlisting}

\subsection{Monadic Normal Form}

The first intermediate language restricts the arguments of the
primitives \lstinline{Sub} and \lstinline{Eq} to be \emph{atomic}
expressions, which we define to include variables and literals. This
restriction gets us closer to x86, where instruction arguments may
only be immediates (literals), registers, or memory accesses.

\begin{lstlisting}
data Atm : Set where
  Num : $‚Ñ§$ $‚Üí$ Atm 
  Bool : $ùîπ$ $‚Üí$ Atm 
  Var : Id $‚Üí$ Atm

data Mon : Set where
  Atom : Atm $‚Üí$ Mon
  Read : Mon
  Sub : Atm $‚Üí$ Atm $‚Üí$ Mon
  Eq : Atm $‚Üí$ Atm $‚Üí$ Mon
  Let : Mon $‚Üí$ Mon $‚Üí$ Mon
  If : Mon $‚Üí$ Mon $‚Üí$ Mon $‚Üí$ Mon
\end{lstlisting}

The interpreter for atoms does not make use of the \lstinline{Reader}
monad because atoms do not have side effects.

\begin{lstlisting}
interp-atm : Atm $‚Üí$ Env Value $‚Üí$ Maybe Value
\end{lstlisting}

The interpreter for \lstinline{Mon} is similar to the
one for \lstinline{Exp}, except that it dispatches
to \lstinline{interp-atm} for atoms. The semantics
of a whole program is given by \lstinline{interp-LMonIf}.

\begin{lstlisting}
interp-mon : Mon $‚Üí$ Env Value $‚Üí$ Reader Value
interp-LMonIf : Mon $‚Üí$ Inputs $‚Üí$ Maybe Value
\end{lstlisting}

(This intermediate language does not correspond to the monadic normal
form in Olivier's paper. It is the language of section
\ref{sec:c-lang} that corresponds to the target of Olivier's one-pass
transformation.)

\subsection{Structured Imperative IR}
\label{sec:imp}

The third language replaces the \lstinline{Let} bindings with
assignment expressions but retains the structured control-flow and
expression-oriented nature of the language. This language brings us
closer to x86 where variables are replaced by registers and stack
locations, all of which are mutable. The abstract syntax for
assignment is \lstinline{(Assign $x$ $e_1$ $e_2$)} where $e_1$ is the
right-hand side and $e_2$ is an expression to be executed after the
assignment (reminiscent of the body of a \lstinline{Let}).  The
\lstinline{Program} AST node consists of the number of variables and
an expression.

\begin{lstlisting}
data Imp-Exp : Set where
  Atom : Atm $‚Üí$ Imp-Exp
  Read : Imp-Exp
  Sub : Atm $‚Üí$ Atm $‚Üí$ Imp-Exp
  Eq : Atm $‚Üí$ Atm $‚Üí$ Imp-Exp
  Assign : Id $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp
  If : Imp-Exp $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp
  
data Imp-Prog : Set where
  Program : $‚Ñï$ $‚Üí$ Imp-Exp $‚Üí$ Imp-Prog
\end{lstlisting}

Regarding the semantics, the main change is that environments are now
both an input and output. Also, in anticipation of the next language,
we switch to representing the semantics as a relation, that is, a
big-step semantics.

\begin{lstlisting}
StateImp = Inputs √ó Env Value
data _$‚ä¢$_$‚áì$_$‚ä£$_ : StateImp $‚Üí$ Imp-Exp
                     $‚Üí$ Value $‚Üí$ StateImp $‚Üí$ Set
\end{lstlisting}

\noindent Here is the rule for assignment:
\[
\inferrule{s , œÅ ‚ä¢ e_1 ‚áì v_1 ‚ä£ s‚Ä≤ , œÅ‚Ä≤ \\
           s‚Ä≤ , œÅ‚Ä≤(x := v_1) ‚ä£ e_2 ‚áì s‚Ä≥ , œÅ‚Ä≥}
          {s , œÅ ‚ä¢ \mathtt{Assign}~ x~ e_1~ e_2 ‚ä£ s‚Ä≥ , œÅ‚Ä≥}
\]

The semantics of whole programs is given by the following relation.

\begin{lstlisting}
interp-imp : Imp-Prog $‚Üí$ Inputs $‚Üí$ Value $‚Üí$ Set
\end{lstlisting}

\subsection{The C-like language}
\label{sec:c-lang}

The fourth language is similar to the C programming language in that
it supports \texttt{goto} and separates expressions from statements.
However, to get us closer to x86, the condition of an \lstinline{if}
statement is restricted to an equality test. This form of
\lstinline{if} can be easily translated into a sequence of three x86
instructions: \lstinline{cmpq}, \lstinline{je}, and \lstinline{jmp}.
However, compiling from the previous IR to this one is non-trivial
because the previous IR allowed arbitrarily nested expressions to
appear in the condition of an \lstinline{if}, including other
\lstinline{if}s!

\begin{lstlisting}
data CExp : Set where
  Atom : Atm $‚Üí$ CExp
  Read : CExp
  Sub : Atm $‚Üí$ Atm $‚Üí$ CExp
  Eq : Atm $‚Üí$ Atm $‚Üí$ CExp

data CStmt : Set where
  Return : CExp $‚Üí$ CStmt
  Assign : Id $‚Üí$ CExp $‚Üí$ CStmt $‚Üí$ CStmt
  IfEq : Atm $‚Üí$ Atm $‚Üí$ Id $‚Üí$ Id $‚Üí$ CStmt
  Goto : Id $‚Üí$ CStmt

CFG = List CStmt

data CProg : Set where
  Program : $‚Ñï$ $‚Üí$ Id $‚Üí$ CFG $‚Üí$ CProg
\end{lstlisting}

Note that the \lstinline{CStmt} type represents not just one statement
but a sequence of statements that always end in either a
\lstinline{Return} statement (that halts the program) or a jump to
another \lstinline{CStmt} via \lstinline{Goto} or \lstinline{IfEq}.
The control flow graph \lstinline{CFG} is a list of \lstinline{CStmt},
and jump labels are indexes into that list.  So \lstinline{Program}
consists of (1) the number of variables, (2) the index of the start
node, (3) the control flow graph.

We choose a big-step semantics for the C-like language because the
semantics is no longer structurally recursive and furthermore,
programs are no longer guaranteed to terminate.\footnote{The programs
in the image of Explicate Control are guaranteed to terminate, but
Agda doesn't know that.}  So encoding the semantics as a function in
Agda would come with complications (such as using a gas parameter)
that we side-step by using a big-step semantics. Compared to the
semantics for the imperative IR, this semantics includes a parameter
for the control flow graph.

\begin{lstlisting}
data _,_$‚ä¢·∂ú$_$‚áì$_$‚ä£$_ : StateImp $‚Üí$ CFG $‚Üí$ CStmt
                      $‚Üí$ Value $‚Üí$ StateImp $‚Üí$ Set
\end{lstlisting}

The rule for \lstinline{Goto} looks up the CFG node for label $l$ and
executes the sequence of statements in that node.
\[
\inferrule{s , G ‚ä¢·∂ú G[l] ‚áì v ‚ä£ s‚Ä≤}
          {s , G ‚ä¢·∂ú \mathtt{Goto}~ l ‚áì v ‚ä£ s‚Ä≤}
\]
\noindent The rule for \lstinline{IfEq}, in the case when the
arguments are equal, is as follows:
\[
\inferrule{\texttt{interp-CExp}(\mathtt{Eq}~a_1~a_2) = \mathsf{just}~\mathsf{true} \\
           s , G ‚ä¢·∂ú G[l_1] ‚áì v ‚ä£ s‚Ä≤}
          {s , G ‚ä¢·∂ú \mathtt{IfEq}~a_1~a_2~l_1~l_2 ‚áì v ‚ä£ s‚Ä≤}
\]

\noindent The semantics of whole programs is given by the following
relation.

\begin{lstlisting}
interp-prog : CProg $‚Üí$ Inputs $‚Üí$ Value $‚Üí$ Set
\end{lstlisting}

\subsection{x86 with variables}

The final intermediate language is a subset of x86 assembly language,
except for the addition of variables. The compiler in \emph{Essentials
of Compilation} includes a few more passes to perform register
allocation and deal with the idiosyncrasies of x86, such as only
allowing at most one instruction argument to access memory.

\begin{lstlisting}
data Arg : Set where
  Num : $‚Ñ§$ $‚Üí$ Arg
  Bool : $ùîπ$ $‚Üí$ Arg
  Var : Id $‚Üí$ Arg
  Reg : $‚Ñï$ $‚Üí$ Arg

data Dest : Set where
  Var : Id $‚Üí$ Dest
  Reg : $‚Ñï$ $‚Üí$ Dest

data Inst : Set where
  MovQ : Arg $‚Üí$ Dest $‚Üí$ Inst
  SubQ : Arg $‚Üí$ Dest $‚Üí$ Inst
  CmpQ : Arg $‚Üí$ Arg $‚Üí$ Inst
  Jmp : Id $‚Üí$ Inst
  JmpEq : Id $‚Üí$ Inst
  ReadInt : Inst

Block : Set
Block = List Inst

data X86Var : Set where
  Program : $‚Ñï$ $‚Üí$ Id $‚Üí$ List Block $‚Üí$ X86Var
\end{lstlisting}

The mutable state consists of the input, the registers, and the
variables. However, we only use one register, \lstinline{rax}.

%input + registers + variables
\begin{lstlisting}
StateX86 = Inputs √ó List Value √ó List Value
\end{lstlisting}

The meaning of each instruction is given by the following relation.
The Boolean in this relation specifies whether the instruction
falls through to the next instruction or not (because it jumped).

\begin{lstlisting}
data _,_$‚ä¢$_$‚áì$_,_ : StateX86 $‚Üí$ List Block $‚Üí$ Inst
                    $‚Üí$ StateX86 $‚Üí$ $ùîπ$ $‚Üí$ Set
\end{lstlisting}

\noindent We take a few liberties to simplify the semantics with
respect to x86 assembly language. For example, our \lstinline{CmpQ}
instruction puts the result of the comparison into \lstinline{rax}
instead of the special \lstinline{EFLAGS} register. Likewise,
\lstinline{JmpEq} does not check the \lstinline{EFLAGS} register, but
instead jumps if \lstinline{rax} contains \lstinline{true}.

The meaning of a sequence of instructions is given the
following big-step relation.

\begin{lstlisting}
data _,_$‚ä©$_$‚áì$_,_ : StateX86 $‚Üí$ List Block $‚Üí$ List Inst
                     $‚Üí$ StateX86 $‚Üí$ $ùîπ$ $‚Üí$ Set 
\end{lstlisting}
This big-step treatment of instruction sequences is unusual, so here
are the three rules.
\begin{gather*}
\inferrule{}{s , B ‚ä© [] ‚áì s , \mathsf{true}} \\[1ex]
\inferrule{s , B ‚ä¢ i ‚áì s‚Ä≤ , \mathsf{true} \\
           s‚Ä≤ , B ‚ä© is ‚áì s‚Ä≥ , b}
          {s , B ‚ä© i ‚à∑ is ‚áì s‚Ä≤ , b}\\[1ex]
\inferrule{s , B ‚ä¢ i ‚áì s‚Ä≤ , \mathsf{false}}
          {s , B ‚ä© i ‚à∑ is ‚áì s‚Ä≤ , \mathsf{false}}
\end{gather*}
The meaning of a program is given by the following relation.
\begin{lstlisting}
interp-x86-var : X86Var $‚Üí$ Inputs $‚Üí$ Value $‚Üí$ Set
\end{lstlisting}
    
Next we discuss the compiler and its proof of correctness.


\section{The Compiler}
\label{sec:compiler}

The compiler is the composition of the four passes, which we detail in
the next four subsections.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
compile e = (select-inst $‚àò$ explicate $‚àò$ lift-locals $‚àò$ rco) e
\end{lstlisting}

To illustrate each pass, we use the source program in
figure~\ref{fig:running-example-source} as a running example,
presented in a concrete syntax with variables as names instead of de
Bruijn indices to enhance readability.  Given the inputs
\lstinline{5}, \lstinline{10}, then \lstinline{0}, the result of this
program is \lstinline{3}.

\begin{figure}[tp]
  \hrule
\begin{lstlisting}
    let x = read in
    let y = read in
    if (if x == 0
        then true
        else read == 1)
    then y - 1
    else (y - 2) - x
\end{lstlisting}
  \hrule
\caption{An example source program.}
\label{fig:running-example-source}
\end{figure}

\subsection{Pass: Remove Complex Operands}

The Remove Complex Operands pass is responsible for making sure that
the arguments of primitive operations, such as \lstinline{Sub} and
\lstinline{Eq}, are atomic expression (variables or literals). It does
so by inserting \lstinline{let} bindings for new temporary variables.
In the running example (figure~\ref{fig:running-example-monadic}), the
subexpressions \lstinline{read} and \lstinline{(y - 2)} are both
arguments of primitive operations, so the Remove Complex Operands pass
binds them to the temporary variables \lstinline{t1} and
\lstinline{t2}, respectively.

\begin{figure}[tp]
  \hrule
\begin{lstlisting}
    let x = read in
    let y = read in
    if (if x == 0
        then true
        else (let t1 = read in t1 == 1))
    then (y - 1)
    else (let t2 = y - 2 in t2 - x)
\end{lstlisting}
  \hrule
\caption{\small Result of Remove Complex Operands on the example.}
\label{fig:running-example-monadic}
\end{figure}

We implement the Remove Complex Operands pass with the following
\lstinline{rco} function in Agda.
\begin{lstlisting}
rco : Exp $‚Üí$ Mon
\end{lstlisting}

Most of the cases of \lstinline{rco} are trivial, but let us focus on
the case for subtraction. We shall start with a straw-man
translation. We recursively compile the subexpressions $e_1$ and
$e_2$. The results might be complex (not atomic), so we
\lstinline{let}-bind them both and replace them in the subtraction
with variables (de Bruijn indices 0 and 1). Note that we must shift
the variables in $e_2$ up by one because we inserted a new
\lstinline{let} above $e_2$. (In general, \lstinline{shift-mon m c}
increases by one each variable in $m$ that is greater or equal to the
cutoff $c$.)

\begin{lstlisting}
rco (Sub e$‚ÇÅ$ e$‚ÇÇ$) =
  Let (rco e$‚ÇÅ$)
   (Let (shift-mon (rco e$‚ÇÇ$) 0)
    (Sub (Var 1) (Var 0)))
\end{lstlisting}

However, the above translation inserts more \lstinline{let} bindings
than are strictly necessary. If $e_1$ and/or $e_2$ compile to an atom,
then there is no need to bind them to a \lstinline{let}.  The
following is an alternative translation for \lstinline{Sub} that
includes four different cases, depending on whether \lstinline{rco e$‚ÇÅ$}
and \lstinline{rco e$‚ÇÇ$} are atomic.

\begin{lstlisting}
rco (Sub e$‚ÇÅ$ e$‚ÇÇ$)
    with rco e$‚ÇÅ$ $|$ rco e$‚ÇÇ$
... $|$ m$‚ÇÅ$ $|$ m$‚ÇÇ$
    with atomic? m$‚ÇÅ$ $|$ atomic? m$‚ÇÇ$
... $|$ yes (atomic a$‚ÇÅ$) $|$ yes (atomic a$‚ÇÇ$) =
      Sub a$‚ÇÅ$ a$‚ÇÇ$
... $|$ no cmplx$‚ÇÅ$ $|$ yes (atomic a$‚ÇÇ$) =
      Let (rco e$‚ÇÅ$) (Sub (Var zero) (shift-atm a$‚ÇÇ$ 0))
... $|$ yes (atomic a$‚ÇÅ$) $|$ no cmplx$‚ÇÇ$ =
      Let (rco e$‚ÇÇ$) (Sub (shift-atm a$‚ÇÅ$ 0) (Var 0))
... $|$ no cmplx$‚ÇÅ$ $|$ no cmplx$‚ÇÇ$ = 
      Let m$‚ÇÅ$
        (Let (shift-mon m$‚ÇÇ$ 0)
          (Sub (Var 1) (Var 0)))
\end{lstlisting}

(It would be nice to collapse the four cases into one, but I have not
yet figured out how to do that while accounting for the necessary
shifting of de Bruijn indices.)

\subsubsection{Remove Complex Operands is Correct}

The correctness theorem for Remove Complex Operands says that for any
program $e$, interpreting $\mathtt{rco}\,e$ with input $s$ yields the
same output as directly interpreting $e$ with the same input.

\begin{lstlisting}
rco-correct : $‚àÄ$ (e : Exp) (s : Inputs)
  $‚Üí$ interp-LMonIf (rco e) s $‚â°$ interp-LIf e s 
\end{lstlisting}

The main lemma is that \lstinline{rco} followed by
\lstinline{interp-mon} is equivalent to \lstinline{interp-exp}.

\begin{lstlisting}
rco-correct-exp : $‚àÄ$ (e : Exp) ($œÅ$ : Env Value)
  $‚Üí$ interp-mon (rco e) $œÅ$ $‚â°$ interp-exp e $œÅ$
\end{lstlisting}

The proof is by structural induction on $e$, but it requires the
following lemmas regarding the shifting of de Bruijn indices.
The idea is that the result of looking up variable $x$ in
environment ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) produces the same result as
shifting the variable by one with the cutoff set to the
the length of $œÅ‚ÇÅ$ and looking it up in the environment
($œÅ‚ÇÅ$ ++ v $‚à∑$ $œÅ‚ÇÇ$), for any value $v$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
nth-++-shift-var : ($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : List A)(v : A)(x : Id)
  $‚Üí$ nth ($œÅ‚ÇÅ$ ++ v $‚à∑$ $œÅ‚ÇÇ$) (shift-var x (length $œÅ‚ÇÅ$))
    $‚â°$ nth ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) x

interp-shift-atm : (a : Atm)(v : Value)($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : Env Value)
  $‚Üí$ interp-atm (shift-atm a (length $œÅ‚ÇÅ$)) ($œÅ‚ÇÅ$ ++ v $‚à∑$ $œÅ‚ÇÇ$) 
    $‚â°$ interp-atm a ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) 

interp-shift-mon : (m : Mon)(v : Value)($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : Env Value)
  $‚Üí$ interp-mon (shift-mon m (length $œÅ‚ÇÅ$)) ($œÅ‚ÇÅ$ ++ (v $‚à∑$ $œÅ‚ÇÇ$))
    $‚â°$ interp-mon m ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$)
\end{lstlisting}


\subsection{Pass: Lift Locals}

The Lift Locals pass is responsible for replacing \lstinline{let}
expressions with assignment statements. In the output language,
variables are declared at the top of the program.  The result of Lift
Locals on the running example is shown in
figure~\ref{fig:running-example-structured-imperative}.

\begin{figure}[tp]
  \hrule
\begin{lstlisting}
    var x, y, t1, t2;
    x := read;
    y := read;
    if (if x == 0
        then true
        else (t1 := read; t1 == 1)
    then (y - 1)
    else (t2 := y - 2; t2 - x)
\end{lstlisting}
  \hrule
  \caption{Result of Lift Locals on the example.}
  \label{fig:running-example-structured-imperative}
\end{figure}
The \lstinline{lift-locals} function delegates to the recursive
function \lstinline{lift-locals-mon}, where all the work is done.
That function returns (1) a number $n$ that counts the number of
\lstinline{let} bindings that were in the expression and (2) the
translation of the expression.

\begin{lstlisting}
lift-locals : Mon $‚Üí$ Imp-Prog
lift-locals m
    with lift-locals-mon m
... $|$ n , e = Program n e    
\end{lstlisting}

\noindent The case of \lstinline{lift-locals-mon} for \lstinline{(Let m$_1$ m$_2$)}
is the most interesting. Think of the result of
\lstinline{lift-locals-mon m$‚ÇÅ$} as a sequence of $i$ imaginary
\lstinline{let}'s surrounding \lstinline{e$‚ÇÅ$}. Similarly for
\lstinline{lift-locals-mon m$‚ÇÅ$}.  The translation result for
\lstinline{(Let m$_1$ m$_2$)} should be a sequence of $i + j + 1$ imaginary
\lstinline{let} bindings followed by an assignment of \lstinline{e$‚ÇÅ$} to
the appropriate variable, and then the code for
\lstinline{e$‚ÇÇ$}. However, we need to shift the variables in
\lstinline{e$‚ÇÅ$} up by $j + 1$ because we are moving all of the $j$
\lstinline{let} bindings for \lstinline{e$‚ÇÇ$} above \lstinline{e$‚ÇÅ$}, as well
as the current \lstinline{let}. Thus, we need another function for
shifting de Bruijn indices by an arbitrary amount.

\begin{lstlisting}
shifts-imp-exp : Imp-Exp $‚Üí$ $‚Ñï$ $‚Üí$ $‚Ñï$ $‚Üí$ Imp-Exp
\end{lstlisting}

The variables in \lstinline{e$‚ÇÇ$} also need to be shifted.  They are
shifted up by $i$ because we are moving all of the $i$
\lstinline{let} bindings for \lstinline{e$‚ÇÅ$} above
\lstinline{e$‚ÇÇ$}. Regarding the variable that serves as the left-hand
side of the assignment, its de Bruijn index is $i + j$ because the
original index for this \lstinline{Let} was $0$ but we have moved $i +
j$ other \lstinline{let}s above this variable occurrence.

\begin{lstlisting}
lift-locals-mon (Let m$‚ÇÅ$ m$‚ÇÇ$)
    with lift-locals-mon m$‚ÇÅ$
... $|$ i , e$‚ÇÅ$
    with lift-locals-mon m$‚ÇÇ$
... $|$ j , e$‚ÇÇ$ =
    let e$‚Ä≤‚ÇÅ$ = shifts-imp-exp e$‚ÇÅ$ 0 (suc j) in
    let e$‚Ä≤‚ÇÇ$ = shifts-imp-exp e$‚ÇÇ$ j i in
    suc (i + j) , Assign (i + j) e$‚Ä≤‚ÇÅ$ e$‚Ä≤‚ÇÇ$
\end{lstlisting}

The case of \lstinline{lift-locals-mon} for \lstinline{If} is also
complicated because there are three subexpressions that must all be
shifted appropriately.

\subsubsection{Lift Locals is Correct}

The correctness theorem for Lift Locals says that if a program output
is $v$ given input $s$, then Lift Locals produces a program that
outputs the same value given the same input.

\begin{lstlisting}
lift-locals-correct : $‚àÄ$(m : Mon)(s : Inputs)(v : Value)
  $‚Üí$ interp-LMonIf m s $‚â°$ just v
  $‚Üí$ interp-imp (lift-locals m) s v
\end{lstlisting}

This theorem is a corollary of the following main lemma, which is
proved by structural induction on the expression \lstinline{m}.
Considerable care is needed in the statement of this lemma so that the
induction hypotheses can be used. Recall that when interpreting an
expression, the environment $œÅ$ provides the meaning for the
\emph{free variables} in the expression.  As the interpreter descends
under \lstinline{let} bindings, it pushes values on the front of the
environment. However, after Lift Locals, all of the variables are
bound at the top, so the initial environment won't be empty, but
instead will have entries for all of the variables (we arbitrarily
initialize them to $0$). So in general, we can separate the
environment into two halves, $œÅ‚ÇÅ$ and $œÅ‚ÇÇ$, where $œÅ‚ÇÇ$ is for the free
variables in \lstinline{m} whereas \lstinline{$œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$} is for the
free variables in the result expression \lstinline{e} of
\lstinline{lift-locals-mon m}. The length of $œÅ‚ÇÅ$ corresponds to the
number returned by \lstinline{lift-locals-mon m}. Also, note that
because \lstinline{Mon} is a pure language, \lstinline{e} contains a
single assignment to each variable, so $œÅ‚ÇÇ$ is unchanged by the
execution of \lstinline{e}. ($œÅ‚ÇÅ$ is changed as each of its variables
are assigned for the first time.)

\begin{lstlisting}
lift-locals-mon-correct : $‚àÄ$(m : Mon)(e : Imp-Exp)
    (s $s‚Ä≤$ : Inputs)(v : Value) ($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : Env Value)
  $‚Üí$ interp-mon m $œÅ‚ÇÇ$ s $‚â°$ just (v , $s‚Ä≤$)
  $‚Üí$ lift-locals-mon m $‚â°$ (length $œÅ‚ÇÅ$ , e)
  $‚Üí$ $‚àÉ$[ $œÅ‚Ä≤‚ÇÅ$ ] (s , $œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) $‚ä¢$ e $‚áì$ v $‚ä£$ ($s‚Ä≤$ , $œÅ‚Ä≤‚ÇÅ$ ++ $œÅ‚ÇÇ$)
      √ó length $œÅ‚ÇÅ$ $‚â°$ length $œÅ‚Ä≤‚ÇÅ$
\end{lstlisting}

The main lemma relies on another lemma about shifting de Bruijn
indices that generalizes our previous one to arbitrary amounts of
shifting.

\begin{lstlisting}
$‚áì$shifts : $‚àÄ${e}{v}{s $s‚Ä≤$}{$œÅ‚ÇÅ$ $œÅ‚Ä≤‚ÇÅ$ $œÅ‚ÇÇ$ $œÅ‚ÇÉ$ $œÅ‚Ä≤‚ÇÉ$} 
  $‚Üí$ (s , $œÅ‚ÇÅ$ ++ $œÅ‚ÇÉ$) $‚ä¢$ e $‚áì$ v $‚ä£$ ($s‚Ä≤$ , $œÅ‚Ä≤‚ÇÅ$ ++ $œÅ‚Ä≤‚ÇÉ$)
  $‚Üí$ length $œÅ‚Ä≤‚ÇÅ$ $‚â°$ length $œÅ‚ÇÅ$
  $‚Üí$ (s , $œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$ ++ $œÅ‚ÇÉ$)
      $‚ä¢$ shifts-imp-exp e (length $œÅ‚ÇÅ$) (length $œÅ‚ÇÇ$)
      $‚áì$ v $‚ä£$ ($s‚Ä≤$ , $œÅ‚Ä≤‚ÇÅ$ ++ $œÅ‚ÇÇ$ ++ $œÅ‚Ä≤‚ÇÉ$)
\end{lstlisting}


\subsection{Pass: Explicate Control}

The Explicate Control pass is responsible for translating from the
structured control-flow of an abstract syntax \emph{tree} into a
language with a goto-based control flow \emph{graph}.\footnote{Our
source language does not include loops, so the graph happens to be a
directed acyclic graph.} In particular, Explicate Control translates
\lstinline{If} expressions, whose conditions may be arbitrary
expressions that include other \lstinline{If} expressions, into the
\lstinline{IfEq} form that only branches based on an equality test. In
so doing, Explicate Control brings together uses of the \lstinline{Eq}
comparison operator and the \lstinline{If} expressions that depend on
them, thereby avoiding the needless extra code that would be generated
by a naive approach.

The output of Explicate Control on the running example is shown in
figure~\ref{fig:running-example-goto}. Note that there are two
\lstinline{goto} statements that target \lstinline{block_2}, so indeed
the control-flow graph of this program is a directed acyclic graph
(DAG) and not a tree. The DAG representation enables sharing so the
pass can avoid the duplication of code. We discuss the trivial blocks
4 and 5 at the end of this section.

\begin{figure}[tp]
  \hrule
\begin{lstlisting}
    var x, y, t1, t2;
    block_0:
       x := read;
       y := read;
       if (x == 0) goto block_1; else goto block_3;
    block_1:
        goto block_2;
    block_2:
        return y - 1;
    block_3:
       t1 := read;
       if (t1 == 1) goto block_4; else goto block_5;
    block_4:
        goto block_2;
    block_5:
        goto block_6;
    block_6:
        t2 := y - 2;
        return t2 - x;
\end{lstlisting}
  \hrule
  \caption{Example after Explicate Control, where control flow
    is made explicit with goto.}
\label{fig:running-example-goto}
\end{figure}

We implement the Explicate Control pass with four functions in Agda,
the \lstinline{explicate} function translates a whole program from the
imperative IR to the C-like language, but it delegates all the work to
the other three functions. These three functions are organized
according to the context in which they are called. Reviewing the
grammar of \lstinline{Imp-Exp} (subsection~\ref{sec:imp}), there are
three contexts in which an \lstinline{Imp-Exp} may appear:
\begin{enumerate}
\item Tail position: the result of the expression is the output of the program,
\item Assignment: the result of the expression is assigned to a variable, and
\item Predicate: the (Boolean) result of the expression determines which
    branch to take in a conditional.
\end{enumerate}

The functions for Assignment and Predicate have extra parameters for
their continuations, one for Assignment and two for Predicate. The
continuations are represented simply as the generated code in the
C-like IL. The function for Tail position of course needs no
continuation parameter.

All three functions build a control flow graph, which needs to be
threaded into and out of these functions, so they use the following
\lstinline{Build} monad:

\begin{lstlisting}
Build A = CFG $‚Üí$ A √ó CFG
retB : {A : Set} $‚Üí$ A $‚Üí$ Build A
_thenB_ : {A B : Set} $‚Üí$ Build A $‚Üí$ (A $‚Üí$ Build B)
           $‚Üí$ Build B
add-node : CStmt $‚Üí$ Build Id
\end{lstlisting}

\noindent The following four functions make up the Explicate Control
pass. Next we discuss selected cases of these functions.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
explicate : Imp-Prog $‚Üí$ CProg
explicate-tail : Imp-Exp $‚Üí$ Build CStmt
explicate-assign : Id $‚Üí$ Imp-Exp $‚Üí$ CStmt $‚Üí$ Build CStmt
explicate-pred : Imp-Exp $‚Üí$ CStmt $‚Üí$ CStmt $‚Üí$ Build CStmt
\end{lstlisting}

\paragraph{Explicate Tail}

Starting with \lstinline{explicate-tail}, in the case of an atomic
expression or primitive operator, we generate a return statement.
Here is the case for subtraction.

\begin{lstlisting}
explicate-tail (Sub a$‚ÇÅ$ a$‚ÇÇ$) = retB (Return (Sub a$‚ÇÅ$ a$‚ÇÇ$))
\end{lstlisting}

\noindent Moving on to the assignment statement, we see a pattern of
compiling the program in reverse. We first compile the continuation
\lstinline{e$‚ÇÇ$}, which is in tail position, producing the code \lstinline{c$‚ÇÇ$}.
We then compile \lstinline{e$‚ÇÅ$}, which is in assignment position,
passing \lstinline{c$‚ÇÇ$} as its continuation.

\begin{lstlisting}
explicate-tail (Assign x e$‚ÇÅ$ e$‚ÇÇ$) =
    (explicate-tail e$‚ÇÇ$) thenB
    $Œª$ c$‚ÇÇ$ $‚Üí$ explicate-assign x e$‚ÇÅ$ c$‚ÇÇ$
\end{lstlisting}

\noindent Regarding a conditional expression, we first compile the two
branches, \lstinline{e$‚ÇÇ$} and \lstinline{e$‚ÇÉ$}, which are both in tail
position, and then compile the condition \lstinline{e$‚ÇÅ$}, which is in
predicate position, so we pass \lstinline{c$‚ÇÇ$} and \lstinline{c$‚ÇÉ$} in
the continuation parameters.

\begin{lstlisting}
explicate-tail (If e$‚ÇÅ$ e$‚ÇÇ$ e$‚ÇÉ$) =
  (explicate-tail e$‚ÇÇ$) thenB
  $Œª$ c$‚ÇÇ$ $‚Üí$ (explicate-tail e$‚ÇÉ$) thenB
  $Œª$ c$‚ÇÉ$ $‚Üí$ explicate-pred e$‚ÇÅ$ c$‚ÇÇ$ c$‚ÇÉ$
\end{lstlisting}

\paragraph{Explicate Assignments}

Turning to \lstinline{explicate-assign}, in each base case (for
atomics and primitive operators), we simply generate an assignment
statement with continuation \lstinline{c}.

\begin{lstlisting}
explicate-assign x (Atom a) c =
  retB (Assign x (Atom a) c)
\end{lstlisting}

The case for conditional expressions is interesting: we do not
directly generate an assignment statement. The two branches,
\lstinline{e$‚ÇÇ$} and \lstinline{e$‚ÇÉ$}, are in assignment position,
so we recursively compile them with \lstinline{explicate-assign}.
They both have the same continuation \lstinline{c} and the first rule
of compilation is that you cannot duplicate code.\footnote{GHC
violated this rule a decade ago:
\url{https://stackoverflow.com/questions/35815503/what-ghc-optimization-is-responsible-for-duplicating-case-expressions}.}
Thus, we add \lstinline{c} to the control-flow graph and
instead use a \lstinline{Goto} to the label for \lstinline{c}
as the continuation for \lstinline{e$‚ÇÇ$} and \lstinline{e$‚ÇÉ$}.

\begin{lstlisting}
explicate-assign y (If e$‚ÇÅ$ e$‚ÇÇ$ e$‚ÇÉ$) c =
   add-node c thenB
   $Œª$ l $‚Üí$ explicate-assign y e$‚ÇÇ$ (Goto l) thenB
   $Œª$ c$‚ÇÇ$ $‚Üí$ explicate-assign y e$‚ÇÉ$ (Goto l) thenB
   $Œª$ c$‚ÇÉ$ $‚Üí$ explicate-pred e$‚ÇÅ$ c$‚ÇÇ$ c$‚ÇÉ$
\end{lstlisting}

\paragraph{Explicate Predicates}

The base cases for \lstinline{explicate-pred} are interesting.  If the
expression is a literal \lstinline{true} or \lstinline{false}, then we
return the continuation for the \lstinline{thn} or \lstinline{els}
branch, respectively. (This may case \lstinline{thn} or
\lstinline{els} to become dead code, which we discuss later.)

\begin{lstlisting}
explicate-pred (Atom (Bool true)) thn els = retB thn
explicate-pred (Atom (Bool false)) thn els = retB els
\end{lstlisting}

\noindent In the case of a variable, we compare it to \lstinline{true}
and branch to either the \lstinline{thn} or \lstinline{els}
continuations. However, the syntax of \lstinline{IfEq} requires labels
to jump to, so we add both continuations to the CFG.

\begin{lstlisting}
explicate-pred (Atom (Var x)) thn els =
  add-node thn thenB
  $Œª$ l$‚ÇÅ$ $‚Üí$ add-node els thenB
  $Œª$ l$‚ÇÇ$ $‚Üí$ retB (IfEq (Var x) (Bool true) l$‚ÇÅ$ l$‚ÇÇ$)
\end{lstlisting}

\noindent The case for an equality comparison delivers on one of the
goals of Explicate Control, which is to combine comparison expressions
with branching whenever possible.

\begin{lstlisting}
explicate-pred (Eq a$‚ÇÅ$ a$‚ÇÇ$) thn els =
  add-node thn thenB
  $Œª$ l$‚ÇÅ$ $‚Üí$ add-node els thenB
  $Œª$ l$‚ÇÇ$ $‚Üí$ retB (IfEq a$‚ÇÅ$ a$‚ÇÇ$ l$‚ÇÅ$ l$‚ÇÇ$)
\end{lstlisting}

For the finale of the Explicate Control pass, we discuss the
translation of the conditional \lstinline{(If e$‚ÇÅ$ e$‚ÇÇ$ e$‚ÇÉ$)}
in \lstinline{explicate-pred}.  The two
branches \lstinline{e$‚ÇÇ$} and \lstinline{e$‚ÇÉ$} are in predicate
position, so we compile them with recursive calls to
\lstinline{explicate-pred} to obtain \lstinline{c$‚ÇÇ$} and
\lstinline{c$‚ÇÉ$}. However, they share the same two continuations,
\lstinline{thn} and \lstinline{els}, so we add both of them to the CFG
to avoid code duplication. We compile \lstinline{e$‚ÇÅ$} with
\lstinline{explicate-pred}, passing \lstinline{c$‚ÇÇ$} and
\lstinline{c$‚ÇÉ$} as the continuations.

\begin{lstlisting}
explicate-pred (If e$‚ÇÅ$ e$‚ÇÇ$ e$‚ÇÉ$) thn els =
   add-node thn thenB
   $Œª$ l$‚ÇÅ$ $‚Üí$ add-node els thenB
   $Œª$ l$‚ÇÇ$ $‚Üí$ explicate-pred e$‚ÇÇ$ (Goto l$‚ÇÅ$) (Goto l$‚ÇÇ$) thenB
   $Œª$ c$‚ÇÇ$ $‚Üí$ (explicate-pred e$‚ÇÉ$ (Goto l$‚ÇÅ$) (Goto l$‚ÇÇ$)) thenB
   $Œª$ c$‚ÇÉ$ $‚Üí$ explicate-pred e$‚ÇÅ$ c$‚ÇÇ$ c$‚ÇÉ$
\end{lstlisting}

\noindent The above handling of \lstinline{If} happens to perform the
case-of-case optimization~\citep{PEYTONJONES19983}.

\paragraph{Discussion}

Throughout the Explicate Control pass we added code to the
control-flow graph whenever we needed to avoid code
duplication. However, some further care is needed to avoid adding (1)
trivial nodes that only contain a \lstinline{Goto} and (2) nodes that
are never the target of a jump (i.e., dead code). The
\lstinline{add-node} function can easily handle (1) by inspecting its
argument and, if it is a \lstinline{Goto}, return its label instead of
adding a new node to the CFG. This optimization is known as
compressing corridor transitions~\citep{Danvy:2009aa}.  Avoiding dead
code (2) is more challenging, either post-process the CFG or use lazy
evaluation to delay the addition of nodes to the CFG to the time when
they are definitely needed~\citep{Siek:2023tr}.

\subsubsection{Explicate Control is Correct}

The correctness theorem for Explicate Control says that if a program
output is $v$ given input $s$, then Explicate Control produces a
program that outputs the same value given the same input.

\begin{lstlisting}
explicate-correct : $‚àÄ$ {p}{s}{v}
  $‚Üí$ interp-imp p s v
  $‚Üí$ interp-prog (explicate p) s v
\end{lstlisting}

The correctness theorem delegates to three lemmas, one for each
\lstinline{explicate-*} function.

\paragraph{Explicate Tail is Correct}

The statement of the lemma for \lstinline{explicate-tail} is the most
straightforward. If expression \lstinline{e} compiles to
\lstinline{c} and \lstinline{e} evaluates to \lstinline{v}, then
\lstinline{c} also evaluates to \lstinline{v}:
\begin{lstlisting}
explicate-tail-correct :
  $‚àÄ${e}{$œÅ$ $œÅ'$}{s s'}{G G$‚Ä≤$}{c}{v}
  $‚Üí$ (s , $œÅ$) $‚ä¢$ e $‚áì$ v $‚ä£$ (s' , $œÅ'$)
  $‚Üí$ explicate-tail e G $‚â°$ (c , G$‚Ä≤$)
  $‚Üí$ (s , $œÅ$) , G$‚Ä≤$ $‚ä¢·∂ú$ c $‚áì$ v $‚ä£$ (s' , $œÅ'$)
\end{lstlisting}
\noindent The cases in the proof of \lstinline{explicate-tail-correct}
for assignment and conditional expressions rely on the correctness
lemmas for \lstinline{explicate-assign} and
\lstinline{explicate-pred}.

The case for conditional expressions requires two lemmas about the
monotonicity of the control flow graph.  The induction hypothesis for
\lstinline{e$‚ÇÇ$} says that the generated \lstinline{c$‚ÇÇ$} evaluates
using the CFG that was produced by the compilation of
\lstinline{e$‚ÇÇ$}, but to satisfy the induction hypothesis
for \lstinline{e$‚ÇÅ$} we need \lstinline{c$‚ÇÇ$} evaluated using the CFG
that was produced by the compilation of \lstinline{e$‚ÇÉ$}.
We define the following notation for
saying that one CFG is a prefix of another CFG:
\begin{lstlisting}
G$‚ÇÅ$ $‚Üù$ G$‚ÇÇ$ = $‚àÉ$[ G ] G$‚ÇÅ$ ++ G $‚â°$ G$‚ÇÇ$
\end{lstlisting}
\noindent We prove that the output CFG of \lstinline{explicate-tail} is
an extension of its input CFG.
\begin{lstlisting}
explicate-tail-CFG : $‚àÄ${e}{G$‚ÇÅ$ G$‚ÇÇ$}{c}
  $‚Üí$ explicate-tail e G$‚ÇÅ$ $‚â°$ (c , G$‚ÇÇ$)
  $‚Üí$ G$‚ÇÅ$ $‚Üù$ G$‚ÇÇ$
\end{lstlisting}
\noindent We prove that the big-step semantics is monotonic with
respect to the $‚Üù$ relation on control flow graphs.
\begin{lstlisting}
eval-CFG : $‚àÄ${c}{$œÅ$ $œÅ‚Ä≤$}{B$‚ÇÅ$ B$‚ÇÇ$}{s s$‚Ä≤$}{v}
  $‚Üí$ B$‚ÇÅ$ $‚Üù$ B$‚ÇÇ$
  $‚Üí$ (s , $œÅ$) , B$‚ÇÅ$ $‚ä¢·∂ú$ c $‚áì$ v $‚ä£$ (s$‚Ä≤$ , $œÅ‚Ä≤$)
  $‚Üí$ (s , $œÅ$) , B$‚ÇÇ$ $‚ä¢·∂ú$ c $‚áì$ v $‚ä£$ (s$‚Ä≤$ , $œÅ‚Ä≤$)
\end{lstlisting}


\paragraph{Explicate Assign is Correct}

The correctness lemma for \lstinline{explicate-assign} adds another
premise which states that the continuation \lstinline{c$‚ÇÇ$} evaluates
in an environment that was updated by the assignment.

\begin{lstlisting}
explicate-assign-correct :
  $‚àÄ${x}{e$‚ÇÅ$}{c$‚ÇÇ$}{$œÅ$ $œÅ‚Ä≤$ $œÅ‚Ä≥$}{s s$‚Ä≤$ s$‚Ä≥$}{G G$‚Ä≤$}{c$‚ÇÅ$}{n v}
  $‚Üí$ (s , $œÅ$) $‚ä¢$ e$‚ÇÅ$ $‚áì$ n $‚ä£$ (s$‚Ä≤$ , $œÅ‚Ä≤$)
  $‚Üí$ (s$‚Ä≤$ , update $œÅ‚Ä≤$ x n) , G $‚ä¢·∂ú$ c$‚ÇÇ$ $‚áì$ v $‚ä£$ (s$‚Ä≥$ , $œÅ‚Ä≥$)
  $‚Üí$ explicate-assign x e$‚ÇÅ$ c$‚ÇÇ$ G $‚â°$ (c$‚ÇÅ$ , G$‚Ä≤$)
  $‚Üí$ (s , $œÅ$) , G$‚Ä≤$ $‚ä¢·∂ú$ c$‚ÇÅ$ $‚áì$ v $‚ä£$ (s$‚Ä≥$ , $œÅ‚Ä≥$)
\end{lstlisting}

\noindent The case for conditional expressions needs another lemma
regarding control flow graphs. Similar to \lstinline{explicate-tail},
we need a lemma which states that the output CFG is an extension of
its input CFG.

\begin{lstlisting}
explicate-assign-CFG : $‚àÄ${x}{m}{c c'}{G$‚ÇÅ$ G$‚ÇÇ$}
  $‚Üí$ explicate-assign x m c G$‚ÇÅ$ $‚â°$ (c' , G$‚ÇÇ$)
  $‚Üí$ G$‚ÇÅ$ $‚Üù$ G$‚ÇÇ$
\end{lstlisting}

\paragraph{Explicate Predicate is Correct}

The following is the statement of correctness for
\lstinline{explicate-pred-correct}.

\begin{lstlisting}
explicate-pred-correct :
  $‚àÄ$ {e$‚ÇÅ$}{c$‚ÇÅ$ c$‚ÇÇ$ c}{b}{v}{s s$‚Ä≤$ s$‚Ä≥$}{$œÅ$ $œÅ‚Ä≤$ $œÅ‚Ä≥$}{G G$‚Ä≤$}
  $‚Üí$ (s , $œÅ$) $‚ä¢$ e$‚ÇÅ$ $‚áì$ Bool b $‚ä£$ (s$‚Ä≤$ , $œÅ‚Ä≤$)
  $‚Üí$ ((s$‚Ä≤$,$œÅ‚Ä≤$) , G $‚ä¢·∂ú$ (if b then c$‚ÇÇ$ else c$‚ÇÉ$) $‚áì$ v $‚ä£$ (s$‚Ä≥$,$œÅ‚Ä≥$))
  $‚Üí$ explicate-pred e$‚ÇÅ$ c$‚ÇÇ$ c$‚ÇÉ$ G $‚â°$ (c$‚ÇÅ$ , G$‚Ä≤$)
  $‚Üí$ (s , $œÅ$) , G$‚Ä≤$ $‚ä¢·∂ú$ c$‚ÇÅ$ $‚áì$ v $‚ä£$ (s$‚Ä≥$ , $œÅ‚Ä≥$)
\end{lstlisting}

\noindent This statement is interesting because it requires the
premise that either continuation \lstinline{c$‚ÇÇ$} or \lstinline{c$‚ÇÉ$}
evaluates to \lstinline{v}, depending on whether the expression
\lstinline{e$‚ÇÅ$} evaluates to \lstinline{true} or
\lstinline{false}. This explains the 
\lstinline{(if b then c$‚ÇÇ$ else c$‚ÇÉ$)} in the second premise.\footnote{The
formulation of this lemma follows that of CompCert's
\lstinline{transl\_condexpr\_prop}.}

The proof of \lstinline{explicate-pred-correct} uses many of the
monotonicity lemmas that we have already proved, plus the following
one.

\begin{lstlisting}
explicate-pred-CFG : $‚àÄ${e}{c$‚ÇÅ$ c$‚ÇÇ$ c}{G$‚ÇÅ$ G$‚ÇÇ$}
  $‚Üí$ explicate-pred e c$‚ÇÅ$ c$‚ÇÇ$ G$‚ÇÅ$ $‚â°$ (c , G$‚ÇÇ$)
  $‚Üí$ G$‚ÇÅ$ $‚Üù$ G$‚ÇÇ$
\end{lstlisting}

\subsection{Pass: Select Instructions}

The responsibility of the Select Instructions pass is to convert the
assignment statements and primitive operations of the C-like language
into x86 instructions. The minor challenge is that many x86
instructions take only two arguments and have an update-in-place
semantics. The output of Select Instructions on the running example is
shown in figure~\ref{fig:running-example-x86}.\footnote{The redundant
\texttt{movq} instructions are removed by the Patch Instructions pass
in \emph{Essentials of Compilation}, which comes after Select
Instructions and Register Allocation.}

\begin{figure}[tp]
  \hrule
\begin{lstlisting}[mathescape=false,basicstyle=\ttfamily\footnotesize]
    var x, y, t1, t2
    block_0:
       callq read_int
       movq %rax, x
       callq read_int
       movq %rax, y
       cmpq x, $0
       je block_1
       jmp block_3
    block_1:
        jmp block_2
    block_2:
        movq y, %rax
        subq $1, %rax
        movq %rax, %rax
    block_3:
        callq read_int
        movq %rax, t1
        cmpq t1, $1
        je block_4
        jmp block_5
    block_4:
        jmp block_2
    block_5:
        jmp block_6
    block_6:
        movq y, %rax
        subq $2, %rax
        movq %rax, t2
        movq t2, %rax
        subq x, %rax
        movq %rax, %rax
\end{lstlisting}
  \hrule
  \caption{Example after Select Instructions, in the x86 assembly language
    augmented with variables.}
\label{fig:running-example-x86}
\end{figure}

The function \lstinline{select-inst} translates a whole program in
the C-like language to x86.
\begin{lstlisting}
select-inst (Program n l B) =
  Program n l (map select-stmt B)
\end{lstlisting}

\noindent The \lstinline{select-stmt} function maps each statement to
one or more instructions. The \lstinline{Return} statement is compiled
like an assignment to the \lstinline{rax} register. (The calling
convention for x86 says that the return value of a function is passed
in \lstinline{rax}.)

\begin{lstlisting}
select-stmt (Return e) = select-assign e (Reg rax)
\end{lstlisting}

\noindent For the assignment statement we delegate to the
\lstinline{select-assign} function, which analyzes the expression
\lstinline{e} to determine which instruction to generate.
We describe \lstinline{select-assign} shortly.

\begin{lstlisting}
select-stmt (Assign x e c) =
  select-assign e (Var x) ++ select-stmt c
\end{lstlisting}

\noindent The \lstinline{IfEq} of the C-like language
is translated to a \lstinline{CmpQ} instruction followed
by \lstinline{JmpEq} and an unconditional \lstinline{Jmp}.

\begin{lstlisting}
select-stmt (IfEq a$_1$ a$_2$ thn els) =
  CmpQ (to-arg a$_1$) (to-arg a$_2$) $‚à∑$
  JmpEq thn $‚à∑$
  Jmp els $‚à∑$ []
\end{lstlisting}

\noindent Finally, we translate \lstinline{Goto} into a \lstinline{Jmp}.
\begin{lstlisting}
select-stmt (Goto l) = Jmp l $‚à∑$ [] 
\end{lstlisting}

Next we look at some representative cases of
\lstinline{select-assign}. The first parameter is the right-hand side
of the assignment and the second parameter is the left-hand side, that
is, the destination. For subtraction, we use the \lstinline{rax}
register as scratch space. We first move argument \lstinline{a$‚ÇÅ$}
into \lstinline{rax}, then subtract \lstinline{a$‚ÇÇ$} from
\lstinline{rax}, and finally move the result into \lstinline{dest}.

\begin{lstlisting}
select-assign (Sub a$‚ÇÅ$ a$‚ÇÇ$) dest =
  MovQ (to-arg a$‚ÇÅ$) (Reg rax) $‚à∑$
  SubQ (to-arg a$‚ÇÇ$) (Reg rax) $‚à∑$
  MovQ (Reg rax) dest $‚à∑$ []
\end{lstlisting}

\noindent Of course there are special cases that require fewer
instructions. For example, if the first argument of the subtraction is
identical to the destination, then we can simply generate one
\lstinline{SubQ} instruction. 

\begin{lstlisting}
select-assign (Sub (Var x) a$‚ÇÇ$) (Var x) = 
  SubQ (to-arg a$‚ÇÇ$) (Var x) $‚à∑$ []
\end{lstlisting}

\noindent For the sake of keeping the proof short, we did not include
any of the special cases.

We compile the assignment of an equality comparison into a
\lstinline{CmpQ} and a \lstinline{MovQ}. The \lstinline{CmpQ} puts its
result into \lstinline{rax}, so the \lstinline{MovQ} is needed to
place the result into the destination.\footnote{The real
\lstinline{cmpq} instruction is stranger still, involving the
\lstinline{EFLAGS} register.}

\begin{lstlisting}
select-assign (Eq a$‚ÇÅ$ a$‚ÇÇ$) dest =
  CmpQ (to-arg a$‚ÇÅ$) (to-arg a$‚ÇÇ$) $‚à∑$
  MovQ (Reg rax) dest $‚à∑$ []
\end{lstlisting}


\subsubsection{Select Instructions is Correct}

The correctness theorem for Select Instructions says that if a program
output is $v$ given input $s$, then Explicate Control produces a
program that outputs the same value given the same input.

\begin{lstlisting}
select-inst-correct : $‚àÄ${p}{s}{v}
  $‚Üí$ interp-prog p s v
  $‚Üí$ interp-x86-var (select-inst p) s v
\end{lstlisting}

The correctness theorem delegates to the correctness lemma for
\lstinline{select-stmt}, which says that if statement \lstinline{c}
evaluates to \lstinline{v}, then the instructions generated for
\lstinline{c} put the same value \lstinline{v} into \lstinline{rax}.
The list of x86 instruction blocks is obtained by mapping
\lstinline{select-stmt} over the control-flow graph \lstinline{G}.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
select-stmt-correct : $‚àÄ$ (c : CStmt) ($œÅ$ $œÅ‚Ä≤$ : Env Value)
  (s s$‚Ä≤$ : Inputs)(regs : List Value)(v : Value)(G : CFG)
  $‚Üí$ (s , $œÅ$) , G $‚ä¢·∂ú$ c $‚áì$ v $‚ä£$ (s$‚Ä≤$ , $œÅ‚Ä≤$)
  $‚Üí$ 0 < length regs
  $‚Üí$ $‚àÉ$[ regs$‚Ä≤$ ] $‚àÉ$[ b ] (s , regs , $œÅ$) , map select-stmt G
         $‚ä©$ select-stmt c $‚áì$ (s$‚Ä≤$ , regs$‚Ä≤$ , $œÅ‚Ä≤$) , b
    √ó nth regs$‚Ä≤$ rax $‚â°$ just v
\end{lstlisting}

When the statement is an assignment, the proof uses the following
lemma. It states that when expression \lstinline{e} evaluates to
\lstinline{v}, the instructions generated for \lstinline{e} put
\lstinline{v} into the specified destination. The predicate
\lstinline{wrote} specifies the update to either the appropriate
variable or register depending on the kind of destination.

\begin{lstlisting}
select-assign-correct : $‚àÄ$ (e : CExp) ($œÅ$ : Env Value)
   (s s$‚Ä≤$ : Inputs) (dest : Dest) (regs : List Value)
   (v : Value) (B : List Block) 
  $‚Üí$ interp-CExp e $œÅ$ s $‚â°$ just (v , s$‚Ä≤$)
  $‚Üí$ 0 < length regs
  $‚Üí$ DestOK dest 1
  $‚Üí$ $‚àÉ$[ st$‚Ä≤$ ] (s , regs , $œÅ$) , B $‚ä©$
            select-assign e dest $‚áì$ st$‚Ä≤$ , true
      √ó wrote dest v (s$‚Ä≤$ , regs , $œÅ$) st$‚Ä≤$
\end{lstlisting}

\noindent The premise \lstinline{0 < length regs} ensures that we at
least have one register (\lstinline{rax}). The premise
\lstinline{DestOK dest 1} ensures that the destination is either a
variable or the register (\lstinline{rax}).

\subsection{The Compiler is Correct}

The correctness theorem for the compiler composes the four correctness
lemmas of the previous subsections.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
compile-correct : (e : Exp) (s : Inputs) (v : Value)
  $‚Üí$ interp-LIf e s $‚â°$ just v
  $‚Üí$ interp-x86-var (compile e) s v
compile-correct e s v ie =
   let i-rco = trans (rco-correct e s) ie in
   let i-lift = lift-locals-correct (rco e) s v i-rco in
   let i-exp = explicate-correct i-lift in
   select-inst-correct i-exp
\end{lstlisting}


\section{Conclusion}
\label{sec:conclusion}

This paper takes a step in adapting the literature on compiler
correctness~\citep{Leroy:2006fe,Kumar:2014aa} to a university course
based on the incremental and nanopass approach of \emph{Essentials of
Compilation}~\citep{Siek:2023tr,Siek:2023ue}. We prove the correctness
of a compiler for a source language with let binding, integer
arithmetic, conditional expressions and Booleans, targeting an
x86-flavored register transfer language. The process of developing
mechanizing the proof in Agda encouraged a further split in the
nanopasses, separating Explicate Control into two passes, one that
lifts \lstinline{let} bindings and the second that compiles structured
control-flow into \lstinline{goto}. In designing these compiler passes
and proofs, it is enjoyable to trace the history of ideas going back
to \citet{Aho:1986qf}, \citet{Dybvig:1990aa}, and Olivier Danvy's
transformation into monadic normal form~\citep{Danvy:2003fk}.


%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{all}


%%
%% If your work has an appendix, this is the place to put it.
%\appendix


\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.

% LocalWords:  sigplan tex docstrip dtx bibtex TeXCount TC envir Siek
% LocalWords:  displaymath Nanopasses authornote authornotemark Tobin
% LocalWords:  rv Trovato al Agda nanopasses Olivier Danvy's ccs desc
% LocalWords:  nanopass Ichiro Aho qf gotos datatypes PEYTONJONES fk
% LocalWords:  Danvy arity Dybvig's Dybvig aa Chez Olivier's CompCert
% LocalWords:  fe Rocq RTLgen CminorSel CompCert's CakeML stackLang tr
% LocalWords:  labLang Kumar ue Sarkar whac de Bruijn kx Eq Exp Num
% LocalWords:  Bool Var Int Env interp exp LIf immediates Atm atm mon
% LocalWords:  LMonIf IR AST Prog StateImp cmpq je jmp CExp CStmt CFG
% LocalWords:  IfEq CProg prog Arg Reg Dest Inst MovQ SubQ CmpQ JmpEq
% LocalWords:  ReadInt rax StateX EFLAGS var inst rco cmplx suc IL ie
% LocalWords:  retB thenB pred GHC thn eval Agda's transl condexpr
% LocalWords:  stmt arg dest regs DestOK trans
