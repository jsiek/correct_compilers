%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,proceedings,bibtex,sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[sigplan,review,dvipsnames,screen,10pt]{acmart}
%\documentclass[sigplan,screen]{acmart}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[OlivierFest '25]{Workshop dedicated to Olivier Danvy's 65th birthday}{October,
  2025}{Singapore}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{mathpartir}
\usepackage{listings}
\usepackage{stmaryrd}

\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}

%\usepackage[verbose]{newunicodechar}
%% \newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}~}}
%% \newunicodechar{ùîπ}{\ensuremath{\mathbb{B}~}}
%\newunicodechar{‚Ñ§}{\ensuremath{\mathbb{Z}~}}
%\newunicodechar{‚Üí}{\ensuremath{~\to~}}
%\newunicodechar{√ó}{\ensuremath{~\times~}}

\newcommand{\LangIf}{$\Lang_{\mathsf{If}}$} %R2
\newcommand{\RCO}{\mathit{mon}} % output of remove-complex-opera*
\newcommand{\LangIfANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{if}}}} %R2
\newcommand{\CLang}{\mathcal{C}}
\newcommand{\LangCIf}{$\CLang_{\mathsf{If}}$} %C1

\newcommand{\TRUE}[0]{\mathsf{true}}
\newcommand{\FALSE}[0]{\mathsf{false}}
\newcommand{\IF}[3]{\mathsf{if}\,#1\,\mathsf{then}\,#2\,\mathsf{else}\,#3}

\newcommand{\CE}[1]{\mathcal{E} \llbracket #1 \rrbracket}
\newcommand{\CB}[3]{\mathcal{B} \llbracket #1 \rrbracket ( #2, #3 )}

\lstset{%
language=Python,
basicstyle=\ttfamily\small,
keywordstyle=\ttfamily\small,
%morekeywords={match,case,bool,int,let,begin,if,else,closure},
%deletekeywords={locals},
%escapechar=|,
mathescape=true,
columns=flexible,
%moredelim=[is][\color{red}]{~}{~},
showstringspaces=false,
%inputencoding=utf8
literate={‚Üí}{{\to}}1,
}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Verified Nanopasses for Compiling Conditionals}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Jeremy G. Siek}
%\authornote{Both authors contributed equally to this research.}
\email{jsiek@iu.edu}
%\orcid{1234-5678-9012}
%% \author{G.K.M. Tobin}
%% \authornotemark[1]
%% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{Indiana University}
  \city{Bloomington}
  \state{IN}
  \country{USA}
}

%% \author{Lars Th{\o}rv{\"a}ld}
%% \affiliation{%
%%   \institution{The Th{\o}rv{\"a}ld Group}
%%   \city{Hekla}
%%   \country{Iceland}}
%% \email{larst@affiliation.org}

%% \author{Valerie B\'eranger}
%% \affiliation{%
%%   \institution{Inria Paris-Rocquencourt}
%%   \city{Rocquencourt}
%%   \country{France}
%% }

%% \author{Aparna Patel}
%% \affiliation{%
%%  \institution{Rajiv Gandhi University}
%%  \city{Doimukh}
%%  \state{Arunachal Pradesh}
%%  \country{India}}

%% \author{Huifen Chan}
%% \affiliation{%
%%   \institution{Tsinghua University}
%%   \city{Haidian Qu}
%%   \state{Beijing Shi}
%%   \country{China}}

%% \author{Charles Palmer}
%% \affiliation{%
%%   \institution{Palmer Research Laboratories}
%%   \city{San Antonio}
%%   \state{Texas}
%%   \country{USA}}
%% \email{cpalmer@prl.com}

%% \author{John Smith}
%% \affiliation{%
%%   \institution{The Th{\o}rv{\"a}ld Group}
%%   \city{Hekla}
%%   \country{Iceland}}
%% \email{jsmith@affiliation.org}

%% \author{Julius P. Kumquat}
%% \affiliation{%
%%   \institution{The Kumquat Consortium}
%%   \city{New York}
%%   \country{USA}}
%% \email{jpkumquat@consortium.net}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We present a proof of correctness in Agda for four nanopasses that
translate a source language with let binding, integer arithmetic,
conditional expressions and Booleans into an x86-flavored register
transfer language. The most interesting of these four nanopasses is a
translation of conditional expressions into goto-style control flow
that uses the continuation-oriented approach of Olivier Danvy's
one-pass transformation into monadic normal form (2003).
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%% \begin{CCSXML}
%% <ccs2012>
%%  <concept>
%%   <concept_id>00000000.0000000.0000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>500</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>00000000.00000000.00000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>300</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>00000000.00000000.00000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>00000000.00000000.00000000</concept_id>
%%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%% </ccs2012>
%% \end{CCSXML}

%% \ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%% \ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%% \ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%% \ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{short-cut boolean evaluation, nanopass, verified compilation, mechanized proof, Agda}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
%% \begin{teaserfigure}
%%   \includegraphics[width=\textwidth]{sampleteaser}
%%   \caption{Seattle Mariners at Spring Training, 2010.}
%%   \Description{Enjoying the baseball game from the third-base
%%   seats. Ichiro Suzuki preparing to bat.}
%%   \label{fig:teaser}
%% \end{teaserfigure}

%% \received{20 February 2007}
%% \received[revised]{12 March 2009}
%% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

The compilation of Boolean expressions and conditionals is a classic
topic in the compiler literature, going back to an algorithm of
\citet{Aho:1986qf} (presented in the form of an attribute grammar)
that translates Boolean expressions and conditionals into gotos. The
compilation of Boolean expressions and conditionals often occurs at an
interesting stage in the compilation pipeline, where the intermediate
language changes from an abstract syntax \emph{tree} into a control
flow \emph{graph}, or equivalently, an intermediate language with
\texttt{goto}. Further, when targeting an assembly language such as
Intel's x86, the naive approach to compiling boolean expressions and
conditionals produces embarassingly inefficient code. Similar issues
arise in the compilation of languages such as Haskell, where the
case-of-case transformation is employed to optimize dispatching on
algebraic datatypes \citep{PEYTONJONES19983}.

Olivier Danvy, in his paper \emph{A New One-Pass Transformation into
Monadic Normal Form}~\citep{Danvy:2003fk}, presents a beautiful family
of structurally recursive functions that translate Boolean expressions
and conditionals into a monadic normal form that (1) no longer
contains Boolean expressions, (2) the condition expression of a
condition is a value, and (3) jumps are expressed using zero-arity
function calls. One of the key parts of that translation is in the
compilation of a conditional expression such as $(\IF{b}{e_1}{e_2})$,
where the expression $b$ is compiled using a special function
$\mathcal{B}$ that takes two more arguments, the generated code for
the two branches. Thus, $\mathcal{B}$ can analyze the expression $b$
to decide how to generate code for the $\mathsf{if}$, or whether an
$\mathsf{if}$ is even necessary.
\[
\CE{\IF{b}{e_1}{e_2}} = \CB{b}{\CE{e_1}}{\CE{e_2}}
\]
For example, in the simple cases where $b$ is $\TRUE$ or $\FALSE$,
no branching is needed.
\begin{align*}
\CB{\TRUE}{c_1}{c_2} &= c_1 \\
\CB{\FALSE}{c_1}{c_2} &= c_2
\end{align*}

My first exposure to these ideas were in Kent Dybvig's compiler
course~\citep{Dybvig:2010aa} where he taught the techniques used in
the Chez Scheme compiler~\citep{Dybvig:2006aa}.  One of those
techniques is called destintation-driven code
generation~\cite{Dybvig:1990aa}, which adds an extra parameter to the
compilation function to indicate how the context will use the result
value of an expression. The context may (1) ignore the result (and
only care about the expression's side effects), (2) branch based on
interpreting its result as a boolean, (3) assign the result to a
variable, or (4) output the result. These options are encoded as a
disjoint union.  Relating this to Olivier's transformation functions,
the $\mathcal{E}$ function is for contexts that need the actual value
and the $\mathcal{B}$ function is for contexts that branch on the
expression's result. Of course, a pair of functions is isomorphic to a
function on a disjoint union.
\[
(A ‚Üí C) √ó (B ‚Üí C) ‚âÖ (A + B) ‚Üí C
\]

The CompCert compiler \citep{Leroy:2006fe} (a compiler for C verified
in Coq) uses the one-function per context approach of Danvy in the
RTLgen pass that translates from the CminorSel intermediate language
to CompCert's register transfer language. The verified CakeML
compiler, on the other hand, employs a naive translation of Boolean
expressions and conditionals for the compilation of stackLang the
intermediate language into labLang~\citep{Kumar:2014aa}.

Towards developing a course on verified compilation, I am interested
in adapting verification techniques from CompCert to the compiler
presented in the \emph{Essentials of Compilation}
textbook~\citep{Siek:2023tr,Siek:2023ue}. That book takes an
incremental approach to teaching compilers, that is, it guides the
students through the creation of multiple compilers for a sequence of
languages, each of which adds a language feature to the previous
langauge. For the language with Boolean expressions and conditionals,
the Explicate Control pass of the compiler uses the one-function per
context approach of Danvy to translate into an x86-flavored register
transfer language.  \emph{Essentials of Compilation} also employs the
nanopass approach, breaking up the compiler into many small passes
that are easier for student to digest~\citep{Sarkar:2004fk}.

This paper presents a proof of correctness in Agda for four nanopasses
that translate a source language with let binding, integer arithmetic,
conditional expressions and Booleans into an x86-flavored register
transfer language. These four passes correspond to the
following three passes in \emph{Essentials of Compilation}:
\begin{enumerate}
\item Remove Complex Operands
\item Explicate Control
\item Select Instructions
\end{enumerate}
The process of proving of correctness of the Explicate Control pass
made it clear to me that it has two distinct reponsibilities that
deserve to be separated:
\begin{itemize}
\item Replacing \texttt{let} expressions with assignment statements.
\item Translating Boolean expressions and conditionals into
  \texttt{goto}-based control-flow.
\end{itemize}
(The RTLgen pass of CompCert also handles the above two
responsibilities.)  So in this paper, the Explicate Control pass is
split into two passes, the first named Lift Locals and the second that
keeps the name Explicate Control.
\begin{enumerate}
\item Remove Complex Operands
\item Lift Locals
\item Explicate Control
\item Select Instructions
\end{enumerate}

TODO: roadmap

%% differs in that I also use a big-step semantics for the register
%% transfer language (instead of small step), which streamlines some of
%% the reasoning.

\section{The Languages}

In this section we describe how we formalize the syntax and semantics
of the source language and four intermediate languages in Agda:
\begin{enumerate}
\item Integers, Booleans, \texttt{let}, and \texttt{if}
\item Monadic Normal Form
\item Imperative with Structured Control Flow
\item A C-like language with \emph{goto}
\item X86 assembly but with variables
\end{enumerate}
These languages and there semantics are quite standard. However, there
are many other intermediate languages in the literature to choose
from, so why these languages, and why in this particular order?  The
answer is that they happen to represent the images of the four
nanopasses.  So then the question becomes, why do we choose to order
the nanopasses in this way? The main thing to consider is that some
passes make later passes easier because they remove a language feature
that would have been complicated to handle. For example, the Lift
Locals pass removes \texttt{let}, and I found \texttt{let} difficult
to deal with in the proof of correctness for Explicate Control
(\texttt{let} is relatively easy to handle in the code for Explicate
Control). The other thing to consider is that some compiler passes use
certain language features in their generated code, so the passes that
remove those language features better come later in the ordering.  For
example, the Closure Conversion pass (not discussed here) generates
code with \texttt{let}, so Closure Conversion comes before Lift
Locals.

One of the challenges of formalizing semantics in a proof assistant is
that one needs to choose a representation of variables. There are many
options, and I've tried most of them. But just like a game of
whac-a-mole, the savings acheived in one place are lost in others.  My
current favorite are good old de Bruijn indices. The following type
\lstinline{Id} is for identifiers.

\begin{lstlisting}
Id = $‚Ñï$
\end{lstlisting}

\subsection{The Source Language}

The source language includes integers, Booleans, \texttt{Let} binding,
and conditional expressions. We choose a couple representative
primitive operators: \texttt{Sub} for integer subtraction and
\texttt{Eq} for equality on integers and Booleans.\footnote{Adding
more primitive operators is straightforward but uninteresting.}  The
\texttt{Read} operation requests an integer input from the user of the
program.\footnote{\texttt{Read} is necessary to prevent students from
interpreting the programs instead of compiling them.}

\begin{lstlisting}
data Exp : Set where
  Num : $‚Ñ§$ $‚Üí$ Exp
  Bool : $ùîπ$ $‚Üí$ Exp
  Read : Exp
  Sub : Exp $‚Üí$ Exp $‚Üí$ Exp
  Eq : Exp $‚Üí$ Exp $‚Üí$ Exp
  Var : Id $‚Üí$ Exp
  Let : Exp $‚Üí$ Exp $‚Üí$ Exp
  If : Exp $‚Üí$ Exp $‚Üí$ Exp $‚Üí$ Exp
\end{lstlisting}

Towards specifying the semantics of this language, the inputs to the
program are an infinite stream of integers represented as a natural
number and a function from the naturals to the integers.  The natural
number is incremented each time the program reads an input.

\begin{lstlisting}
Inputs = $‚Ñï$ $√ó$ ($‚Ñï$ $‚Üí$ $‚Ñ§$)
\end{lstlisting}

The following monad is used to thread the inputs through the
interpreter and to account for partiality via \lstinline{Maybe}
(e.g. looking up an undefined variable).

\begin{lstlisting}
Reader A = Inputs $‚Üí$ Maybe (A $√ó$ Inputs)
\end{lstlisting}

\noindent The result of an expression is an integer or Boolean, for which we
define the \lstinline{Value} type.

\begin{lstlisting}
data Value : Set where
  Int : $‚Ñ§$ $‚Üí$ Value
  Bool : $ùîπ$ $‚Üí$ Value
\end{lstlisting}

\noindent The variables (de Bruijn indices) are interpreted using an
environment that is represented as a list of values.

\begin{lstlisting}
Env A = List A
\end{lstlisting}

\noindent The semantics of expressions is given by the
\lstinline{interp-exp} function, which maps an expression and
environment to a value, in our \lstinline{Reader} monad.

\begin{lstlisting}
interp-exp : Exp $‚Üí$ Env Value $‚Üí$ Reader Value
\end{lstlisting}

\noindent The semantics of a whole program is given by the
\lstinline{interp-LIf} function.

\begin{lstlisting}
interp-LIf : Exp $‚Üí$ Inputs $‚Üí$ Maybe Value
\end{lstlisting}

\subsection{Monadic Normal Form}

The first intermediate language restricts the arguments of the
primitives \lstinline{Sub} and \lstinline{Eq} to be \emph{atomic}
expressions, which we define to include variables and literals. This
restriction gets us closer to x86, where instruction arguments may
only be immediates (literals), registers, or memory accesses.

\begin{lstlisting}
data Atm : Set where
  Num : $‚Ñ§$ $‚Üí$ Atm 
  Bool : $ùîπ$ $‚Üí$ Atm 
  Var : Id $‚Üí$ Atm

data Mon : Set where
  Atom : Atm $‚Üí$ Mon
  Read : Mon
  Sub : Atm $‚Üí$ Atm $‚Üí$ Mon
  Eq : Atm $‚Üí$ Atm $‚Üí$ Mon
  Let : Mon $‚Üí$ Mon $‚Üí$ Mon
  If : Mon $‚Üí$ Mon $‚Üí$ Mon $‚Üí$ Mon
\end{lstlisting}

The interpreter for atoms does not make use of the \lstinline{Reader}
monad because atoms do not have side effects.

\begin{lstlisting}
interp-atm : Atm $‚Üí$ Env Value $‚Üí$ Maybe Value
\end{lstlisting}

The interpreter for \lstinline{Mon} is similar to the
one for \lstinline{Exp}, except that it dispatches
to \lstinline{interp-atm} for atoms. The semantics
of a whole program is given by \lstinline{interp-LMonIf}.

\begin{lstlisting}
interp-mon : Mon $‚Üí$ Env Value $‚Üí$ Reader Value
interp-LMonIf : Mon $‚Üí$ Inputs $‚Üí$ Maybe Value
\end{lstlisting}

\subsection{Structured Imperative IR}

The third language replaces the \lstinline{Let} bindings with
assignment expressions but retains the structured control-flow and
expression-oriented nature of the language. This language brings us
closer to x86 because variables are represented by registers and stack
locations, all of which are mutable. The abstract syntax for
assignment is \lstinline{(Assign $x$ $e_1$ $e_2$)} where $e_1$ is the
right-hand side and $e_2$ is an expression to be executed after the
assignment (reminiscent of the body of a \lstinline{Let}).  The
\lstinline{Program} AST node consists of the number of variables and
an expression.

\begin{lstlisting}
data Imp-Exp : Set where
  Atom : Atm $‚Üí$ Imp-Exp
  Read : Imp-Exp
  Sub : Atm $‚Üí$ Atm $‚Üí$ Imp-Exp
  Eq : Atm $‚Üí$ Atm $‚Üí$ Imp-Exp
  Assign : Id $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp
  If : Imp-Exp $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp $‚Üí$ Imp-Exp
  
data Imp-Prog : Set where
  Program : $‚Ñï$ $‚Üí$ Imp-Exp $‚Üí$ Imp-Prog
\end{lstlisting}

Regarding the semantics, the main change is that environments are now
both an input and output. Also, in anticipation of the next language,
we switch to representing the semantics as a relation, that is, a
big-step semantics.

\begin{lstlisting}
StateImp = Inputs √ó Env Value
data _$‚ä¢$_$‚áì$_$‚ä£$_ : StateImp $‚Üí$ Imp-Exp
                     $‚Üí$ Value $‚Üí$ StateImp $‚Üí$ Set
\end{lstlisting}

\noindent Here is the rule for assignment:
\[
\inferrule{s , œÅ ‚ä¢ e_1 ‚áì v_1 ‚ä£ s‚Ä≤ , œÅ‚Ä≤ \\
           s‚Ä≤ , œÅ‚Ä≤(x := v_1) ‚ä£ e_2 ‚áì s‚Ä≥ , œÅ‚Ä≥}
          {s , œÅ ‚ä¢ \mathtt{Assign}~ x~ e_1~ e_2 ‚ä£ s‚Ä≥ , œÅ‚Ä≥}
\]

The semantics of whole programs is given by the following relation.

\begin{lstlisting}
interp-imp : Imp-Prog $‚Üí$ Inputs $‚Üí$ Value $‚Üí$ Set
\end{lstlisting}

\subsection{The C-like language}

The fourth language is similar to the C programming language in that
it supports \texttt{goto} and separates expressions from statements.
However, to get us closer to x86, the condition of an \lstinline{if}
statement is restricted to an equality test. This form of
\lstinline{if} can be easily translated into a sequence of three x86
instructions: \lstinline{cmpq}, \lstinline{je}, and \lstinline{jmp}.
However, compiling from the previous IR to this one is non-trivial
because the previous IR allowed arbitrarily nested expressions to
appear in the condition of an \lstinline{if}, including other
\lstinline{if}'s!

\begin{lstlisting}
data CExp : Set where
  Atom : Atm $‚Üí$ CExp
  Read : CExp
  Sub : Atm $‚Üí$ Atm $‚Üí$ CExp
  Eq : Atm $‚Üí$ Atm $‚Üí$ CExp

data CStmt : Set where
  Return : CExp $‚Üí$ CStmt
  Assign : Id $‚Üí$ CExp $‚Üí$ CStmt $‚Üí$ CStmt
  IfEq : Atm $‚Üí$ Atm $‚Üí$ Id $‚Üí$ Id $‚Üí$ CStmt
  Goto : Id $‚Üí$ CStmt

data CProg : Set where
  Program : $‚Ñï$ $‚Üí$ Id $‚Üí$ List CStmt $‚Üí$ CProg
\end{lstlisting}

Note that the \lstinline{CStmt} type represents not just one statement
but a block of statements that always end in either a
\lstinline{Return} statement (that halts the program) or a jump to
another block (\lstinline{Goto} or \lstinline{IfEq}).

We choose a big-step semantics for C-like language because the
semantics is no longer structurally recursive and furthermore,
programs are no longer guaranteed to terminate.\footnote{The programs
in the image of Explicate Control are guaranteed to terminate, but
Agda doesn't know that.}  So encoding the semantics as a function in
Agda would come with complications (such as using a gas parameter)
that can be side-stepped by using a big-step semantics. Compared to
the semantics for the imperative IR, this semantics refers to a list
of blocks $B$ that can be the targets of gotos.

\begin{lstlisting}
data _,_$‚ä¢·∂ú$_$‚áì$_$‚ä£$_ : StateImp $‚Üí$ List CStmt $‚Üí$ CStmt
                      $‚Üí$ Value $‚Üí$ StateImp $‚Üí$ Set
\end{lstlisting}

The rule for \lstinline{Goto} looks up the block for label $l$ and
executes that block.
\[
\inferrule{s , B ‚ä¢·∂ú B[l] ‚áì v ‚ä£ s‚Ä≤}
          {s , B ‚ä¢·∂ú \mathtt{Goto}~ l ‚áì v ‚ä£ s‚Ä≤}
\]
\noindent The rule for \lstinline{IfEq}, in the case when the
arguments are equal, is as follows:
\[
\inferrule{\texttt{interp-CExp}(\mathtt{Eq}~a_1~a_2) = \mathsf{just}~\mathsf{true} \\
           s , B ‚ä¢·∂ú B[l_1] ‚áì v ‚ä£ s‚Ä≤}
          {s , B ‚ä¢·∂ú \mathtt{IfEq}~a_1~a_2~l_1~l_2 ‚áì v ‚ä£ s‚Ä≤}
\]

\noindent The semantics of whole programs is given by the following
relation.

\begin{lstlisting}
interp-prog : CProg $‚Üí$ Inputs $‚Üí$ Value $‚Üí$ Set
\end{lstlisting}

\subsection{x86 with variables}

The final intermediate language is a subset of x86 assembly language,
except for the addition of variables. A complete compiler would
include a few more passes to perform register allocation and deal with
idiosyncrosies of x86, such as only allowing at most one instruction
argument to access memory.

\begin{lstlisting}
data Arg : Set where
  Num : $‚Ñ§$ $‚Üí$ Arg
  Bool : $ùîπ$ $‚Üí$ Arg
  Var : Id $‚Üí$ Arg
  Reg : $‚Ñï$ $‚Üí$ Arg

data Dest : Set where
  Var : Id $‚Üí$ Dest
  Reg : $‚Ñï$ $‚Üí$ Dest

data Inst : Set where
  MovQ : Arg $‚Üí$ Dest $‚Üí$ Inst
  SubQ : Arg $‚Üí$ Dest $‚Üí$ Inst
  CmpQ : Arg $‚Üí$ Arg $‚Üí$ Inst
  Jmp : Id $‚Üí$ Inst
  JmpEq : Id $‚Üí$ Inst
  ReadInt : Inst

Block : Set
Block = List Inst

data X86Var : Set where
  Program : $‚Ñï$ $‚Üí$ Id $‚Üí$ List Block $‚Üí$ X86Var
\end{lstlisting}

The mutable state consists of the input, the registers, and the
variables. However, we only use one register, \lstinline{rax}.

%input + registers + variables
\begin{lstlisting}
StateX86 = Inputs √ó List Value √ó List Value
\end{lstlisting}

The meaning of each instruction is given by the following relation.
The Boolean in this relation specifies whether the instruction
falls-through to the next instruction or not (because it jumped).

\begin{lstlisting}
data _,_$‚ä¢$_$‚áì$_,_ : StateX86 $‚Üí$ List Block $‚Üí$ Inst
                    $‚Üí$ StateX86 $‚Üí$ $ùîπ$ $‚Üí$ Set
\end{lstlisting}

\noindent We take a few liberties to simplify the semantics with
respect to x86 assembly language. For example, our \lstinline{CmpQ}
instruction puts the result of the comparison into \lstinline{rax}
instead of the special \lstinline{EFLAGS} register. Likewise,
\lstinline{JmpEq} does not check the \lstinline{EFLAGS} register, but
instead jumps if \lstinline{rax} contains \lstinline{true}.

\noindent The meaning of a sequence of instructions is given the
following big-step relation.

\begin{lstlisting}
data _,_$‚ä©$_$‚áì$_,_ : StateX86 $‚Üí$ List Block $‚Üí$ List Inst
                     $‚Üí$ StateX86 $‚Üí$ $ùîπ$ $‚Üí$ Set 
\end{lstlisting}

This big-step treatment of the semantics of instruction sequences is
unusual, so here are the three rules.

\begin{gather*}
\inferrule{}{s , B ‚ä© [] ‚áì s , \mathsf{true}} \\[1ex]
\inferrule{s , B ‚ä¢ i ‚áì s‚Ä≤ , \mathsf{true} \\
           s‚Ä≤ , B ‚ä© is ‚áì s‚Ä≥ , b}
          {s , B ‚ä© i ‚à∑ is ‚áì s‚Ä≤ , b}\\[1ex]
\inferrule{s , B ‚ä¢ i ‚áì s‚Ä≤ , \mathsf{false}}
          {s , B ‚ä© i ‚à∑ is ‚áì s‚Ä≤ , b}
\end{gather*}

The meaning of a whole program is given by the following relation.
\begin{lstlisting}
interp-x86-var : X86Var ‚Üí Inputs ‚Üí Value ‚Üí Set
\end{lstlisting}
    
We now proceed to discuss each compiler pass and its proof of
correctness.

\section{Pass: Remove Complex Operands}

We implement the Remove Complex Operands pass with the following
\lstinline{rco} function in Agda. This pass is responsible for making
sure that the arguments of primitive operations, such as
\lstinline{Sub} and \lstinline{Eq}, are atomic expression (variables
or literals).

\begin{lstlisting}
rco : Exp $‚Üí$ Mon
\end{lstlisting}

Most of the cases of \lstinline{rco} are trivial, but let us focus on
the case for subtraction. We shall start with a strawman
translation. We recursively compile the subexpressions $e_1$ and
$e_2$. The results might be complex (not atomic), so we
\lstinline{let} binding them both and replace them in the subtraction
with variables (de Bruijn indices 0 and 1). Note that we must shift
the variables in $e_2$ up by one because we inserted a new
\lstinline{let} above $e_2$. (In general, \lstinline{shift-mon m c}
increases by one each variable in $m$ that is greater or equal to the
cutoff $c$.)

\begin{lstlisting}
rco (Sub e$‚ÇÅ$ e$‚ÇÇ$) =
  Let (rco e$‚ÇÅ$)
   (Let (shift-mon (rco e$‚ÇÇ$) 0)
    (Sub (Var 1) (Var 0)))
\end{lstlisting}

However, the above translation inserts more \lstinline{let} bindings
than are strictly necessary. If $e_1$ and/or $e_2$ compile to an atom,
then there is no need to bind them to a \lstinline{let}.  The
following is an alternative translation for \lstinline{Sub} that
includes four different cases, depending on whether \lstinline{rco e$‚ÇÅ$}
and \lstinline{rco e$‚ÇÇ$} are atomic.

\begin{lstlisting}
rco (Sub e$‚ÇÅ$ e$‚ÇÇ$)
    with rco e$‚ÇÅ$ | rco e$‚ÇÇ$
... | m$‚ÇÅ$ | m$‚ÇÇ$
    with atomic? m$‚ÇÅ$ | atomic? m$‚ÇÇ$
... | yes (atomic a$‚ÇÅ$) | yes (atomic a$‚ÇÇ$) =
      Sub a$‚ÇÅ$ a$‚ÇÇ$
... | no cmplx$‚ÇÅ$ | yes (atomic a$‚ÇÇ$) =
      Let (rco e$‚ÇÅ$) (Sub (Var zero) (shift-atm a$‚ÇÇ$ 0))
... | yes (atomic a$‚ÇÅ$) | no cmplx$‚ÇÇ$ =
      Let (rco e$‚ÇÇ$) (Sub (shift-atm a$‚ÇÅ$ 0) (Var 0))
... | no cmplx$‚ÇÅ$ | no cmplx$‚ÇÇ$ = 
      Let m$‚ÇÅ$
        (Let (shift-mon m$‚ÇÇ$ 0)
          (Sub (Var 1) (Var 0)))
\end{lstlisting}

(It would be nice to collapse the four cases into one, but I have not
yet figured out how to do that while accounting for the necessary
shifting of de Bruijn indices.)

The correctness theorem for Remove Complex Operands says that for any
program $e$, interpreting $\mathtt{rco}\,e$ with input $s$ yields the
same output as directly interpreting $e$ with the same input.

\begin{lstlisting}
rco-correct : $‚àÄ$ (e : Exp) (s : Inputs)
  $‚Üí$ interp-LMonIf (rco e) s $‚â°$ interp-LIf e s 
\end{lstlisting}

The main lemma is that \lstinline{rco} followed by
\lstinline{interp-mon} is equivalent to \lstinline{interp-exp}.

\begin{lstlisting}
rco-correct-exp : ‚àÄ (e : Exp) (œÅ : Env Value)
  ‚Üí interp-mon (rco e) œÅ ‚â° interp-exp e œÅ
\end{lstlisting}

The proof is by structural induction on $e$, but it requires the
following lemmas regarding the shifting of de Bruijn indices.
The idea is that the result of looking up variable $x$ in
environment ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) produces the same result as
shifting the variable by one with the cutoff set to the
the length of $œÅ‚ÇÅ$ and looking it up in the environment
($œÅ‚ÇÅ$ ++ v $‚à∑$ $œÅ‚ÇÇ$), for any value $v$.

\begin{lstlisting}
nth-++-shift-var : ($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : List A)(v : A)(x : Id)
  $‚Üí$ nth ($œÅ‚ÇÅ$ ++ v $‚à∑$ $œÅ‚ÇÇ$) (shift-var x (length $œÅ‚ÇÅ$))
    $‚â°$ nth ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) x

interp-shift-atm : (a : Atm)(v : Value)($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : Env Value)
  $‚Üí$ interp-atm (shift-atm a (length $œÅ‚ÇÅ$)) ($œÅ‚ÇÅ$ ++ v $‚à∑$ $œÅ‚ÇÇ$) 
    $‚â°$ interp-atm a ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) 

interp-shift-mon : (m : Mon)(v : Value)($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : Env Value)
  $‚Üí$ interp-mon (shift-mon m (length $œÅ‚ÇÅ$)) ($œÅ‚ÇÅ$ ++ (v $‚à∑$ $œÅ‚ÇÇ$))
    $‚â°$ interp-mon m ($œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$)
\end{lstlisting}


\section{Pass: Lift Locals}

The Lift Locals pass is responsible for replacing all of the
\lstinline{let} expressions with assignment statements.  After this
pass, variables are still represented by de Bruijn indices but they
are all bound by the \lstinline{Program} AST node.

The \lstinline{lift-locals} function delegates to the recursive
function \lstinline{lift-locals-mon}, where all the work is done.
That function returns a number $n$ that counts the number of
\lstinline{let} bindings in the expression, and the translated
expression.

\begin{lstlisting}
lift-locals : Mon ‚Üí Imp-Prog
lift-locals m
    with lift-locals-mon m
... | n , e = Program n e    
\end{lstlisting}

\noindent The case of \lstinline{lift-locals-mon} for \lstinline{Let}
is the most interesting. One can imagine that the result of
\lstinline{lift-locals-mon m$‚ÇÅ$} is a sequence of $i$ imaginary
\lstinline{let}'s surrounding \lstinline{e$‚ÇÅ$}. Similarly for 
\lstinline{lift-locals-mon m$‚ÇÅ$}.
The translation result for this \lstinline{Let} should be
a sequence of $i + j + 1$ imaginary
\lstinline{let}'s, followed by an assignment
of \lstinline{e$‚ÇÅ$} to the appropriate variable, and then the
code for \lstinline{e$‚ÇÇ$}. However, we need to shift
the variables in \lstinline{e$‚ÇÅ$} up by $j + 1$ because
we are moving all of the $j$ \lstinline{let}'s for
\lstinline{e$‚ÇÇ$} above \lstinline{e$‚ÇÅ$}, as well as the
current \lstinline{let}. Thus, we need another function
for shifting de Bruijn indices by an arbitrary amount.

\begin{lstlisting}
shifts-imp-exp : Imp-Exp $‚Üí$ $‚Ñï$ $‚Üí$ $‚Ñï$ $‚Üí$ Imp-Exp
\end{lstlisting}

The variables in \lstinline{e$‚ÇÇ$} also need to be shifted.  They are
shifted up by $i$ because we are moving all of the $i$
\lstinline{let}'s for \lstinline{e$‚ÇÅ$} above
\lstinline{e$‚ÇÇ$}. Regarding the variable that serves as the left-hand
side of the assignment, its de Bruijn index is $i + j$ because the
original index for this \lstinline{Let} was $0$ but we have moved $i +
j$ other \lstinline{let}s above this variable occurence.

\begin{lstlisting}
lift-locals-mon (Let m$‚ÇÅ$ m$‚ÇÇ$)
    with lift-locals-mon m$‚ÇÅ$
... | i , e$‚ÇÅ$
    with lift-locals-mon m$‚ÇÇ$
... | j , e$‚ÇÇ$ =
    let e$‚Ä≤‚ÇÅ$ = shifts-imp-exp e$‚ÇÅ$ 0 (suc j) in
    let e$‚Ä≤‚ÇÇ$ = shifts-imp-exp e$‚ÇÇ$ j i in
    suc (i + j) , Assign (i + j) e$‚Ä≤‚ÇÅ$ e$‚Ä≤‚ÇÇ$
\end{lstlisting}

The case of \lstinline{lift-locals-mon} for \lstinline{If} is also
complicated because there are three subexpressions that must all be
shifted appropriately.

The correctness theorem for Lift Locals says that if a program output
is $v$ given input $s$, then Lift Locals produces a program that
outputs the same value given the same input.

\begin{lstlisting}
lift-locals-correct : $‚àÄ$(m : Mon)(s : Inputs)(v : Value)
  $‚Üí$ interp-LMonIf m s $‚â°$ just v
  $‚Üí$ interp-imp (lift-locals m) s v
\end{lstlisting}

This theorem is a corollary of the following main lemma, which is
proved by structural induction on the expression \lstinline{m}.
Considerable care is needed in the statement of this lemma so that the
induction hypotheses can be used. Recall that when interpreting an
expression, the environment $œÅ$ provides the meaning for the
\emph{free variables} in the expression.  As the interpreter descends
under \lstinline{let} bindings, it pushes values on the front of the
environment. However, after Lift Locals, all of the variables are
bound at the top, so the initial environment won't be empty, but
instead will have entries for all of the variables (we arbitrarily
initialize them to $0$). So in general, we can separate the
environment into two halves, $œÅ‚ÇÅ$ and $œÅ‚ÇÇ$, where $œÅ‚ÇÇ$ is for the free
variables in \lstinline{m} whereas \lstinline{$œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$} is for the
free variables in the result expressoin \lstinline{e} of
\lstinline{lift-locals-mon m}. The length of $œÅ‚ÇÅ$ corresponds to the
number returned by \lstinline{lift-locals-mon m}. Also, note that
because \lstinline{Mon} is a pure language, \lstinline{e} contains a
single assignment to each variable, so $œÅ‚ÇÇ$ is unchanged by the
execution of \lstinline{e}. ($œÅ‚ÇÅ$ is changed as each of its variables
are assigned to for the first time.)

\begin{lstlisting}
lift-locals-mon-correct : $‚àÄ$(m : Mon)(e : Imp-Exp)
    (s $s‚Ä≤$ : Inputs)(v : Value) ($œÅ‚ÇÅ$ $œÅ‚ÇÇ$ : Env Value)
  $‚Üí$ interp-mon m $œÅ‚ÇÇ$ s $‚â°$ just (v , $s‚Ä≤$)
  $‚Üí$ lift-locals-mon m $‚â°$ (length $œÅ‚ÇÅ$ , e)
  $‚Üí$ $‚àÉ$[ $œÅ‚Ä≤‚ÇÅ$ ] (s , $œÅ‚ÇÅ$ ++ $œÅ‚ÇÇ$) $‚ä¢$ e $‚áì$ v $‚ä£$ ($s‚Ä≤$ , $œÅ‚Ä≤‚ÇÅ$ ++ $œÅ‚ÇÇ$)
      √ó length $œÅ‚ÇÅ$ $‚â°$ length $œÅ‚Ä≤‚ÇÅ$
\end{lstlisting}

The main lemma relies on more lemmas about shifting de Bruijn indices
that generalize our previous ones to arbitrary amounts of shifting.

\begin{lstlisting}
$‚áì$shifts : $‚àÄ${e}{v}{s $s‚Ä≤$}{$œÅ‚ÇÅ$ $œÅ‚Ä≤‚ÇÅ$ $œÅ‚ÇÇ$ $œÅ‚ÇÉ$ $œÅ‚Ä≤‚ÇÉ$} 
  $‚Üí$ (s , $œÅ‚ÇÅ$++$œÅ‚ÇÉ$) $‚ä¢$ e $‚áì$ v $‚ä£$ ($s‚Ä≤$ , $œÅ‚Ä≤‚ÇÅ$++$œÅ‚Ä≤‚ÇÉ$)
  $‚Üí$ length $œÅ‚Ä≤‚ÇÅ$ $‚â°$ length $œÅ‚ÇÅ$
  $‚Üí$ (s , $œÅ‚ÇÅ$++$œÅ‚ÇÇ$++$œÅ‚ÇÉ$) $‚ä¢$
       shifts-imp-exp e (length $œÅ‚ÇÅ$) (length $œÅ‚ÇÇ$)
       $‚áì$ v $‚ä£$ ($s‚Ä≤$ , $œÅ‚Ä≤‚ÇÅ$++$œÅ‚ÇÇ$++$œÅ‚Ä≤‚ÇÉ$)
\end{lstlisting}


\section{Pass: Explicate Control}

\section{Pass: Select Instructions}

\section{The Compiler is Correct}



%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{all}


%%
%% If your work has an appendix, this is the place to put it.
%\appendix


\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
