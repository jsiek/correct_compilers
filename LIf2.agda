module LIf2 where

open import Agda.Builtin.Unit
open import Data.Nat using (‚Ñï; zero; suc; _‚â§·µá_; _<_; _+_; _‚â°·µá_)
open import Data.Nat.Properties
open import Data.Product hiding (map)
open import Data.Integer using (‚Ñ§; -_; _-_; 0‚Ñ§)
open import Data.List
open import Data.Maybe hiding (map)
open import Function.Base using (_‚àò_)
open import Relation.Binary.PropositionalEquality
   using (_‚â°_; refl; trans; sym; cong; cong-app)
open import Agda.Builtin.Bool renaming (Bool to ùîπ)
open import Reader
open import Utilities
open import Relation.Nullary using (Dec; yes; no)

----------------- Definition of LIf ----------------------------

data Exp : Set where
  Num : ‚Ñ§ ‚Üí Exp
  Bool : ùîπ ‚Üí Exp
  Read : Exp
  Sub : Exp ‚Üí Exp ‚Üí Exp
  Eq : Exp ‚Üí Exp ‚Üí Exp
  Var : (i : Id) ‚Üí Exp
  Let : Exp ‚Üí Exp ‚Üí Exp
  If : Exp ‚Üí Exp ‚Üí Exp ‚Üí Exp

data Value : Set where
  Int : ‚Ñ§ ‚Üí Value
  Bool : ùîπ ‚Üí Value

sub : Value ‚Üí Value ‚Üí Maybe Value
sub (Int x) (Int y) = just (Int (x - y))
sub (Int x) (Bool x‚ÇÅ) = nothing
sub (Bool x) v2 = nothing

equal : Value ‚Üí Value ‚Üí Maybe Value
equal (Int (‚Ñ§.pos x)) (Int (‚Ñ§.pos y)) = just (Bool (x ‚â°·µá y))
equal (Int (‚Ñ§.pos n)) (Int (‚Ñ§.negsuc n‚ÇÅ)) = just (Bool false)
equal (Int (‚Ñ§.negsuc n)) (Int (‚Ñ§.pos n‚ÇÅ)) = just (Bool false)
equal (Int (‚Ñ§.negsuc x)) (Int (‚Ñ§.negsuc y)) = just (Bool (x ‚â°·µá y))
equal (Int x) (Bool y) = nothing
equal (Bool x) (Int y) = nothing
equal (Bool false) (Bool false) = just (Bool true)
equal (Bool false) (Bool true) = just (Bool false)
equal (Bool true) (Bool false) = just (Bool false)
equal (Bool true) (Bool true) = just (Bool true)

interp-exp : Exp ‚Üí Env Value ‚Üí Reader Value
interp-exp (Num n) œÅ = return (Int n)
interp-exp (Bool b) œÅ = return (Bool b)
interp-exp Read œÅ = read-int Int
interp-exp (Sub e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí (interp-exp e‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí try (sub v‚ÇÅ v‚ÇÇ)
interp-exp (Eq e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí (interp-exp e‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí try (equal v‚ÇÅ v‚ÇÇ)
interp-exp (Var i) œÅ = try (nth œÅ i)
interp-exp (Let e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí interp-exp e‚ÇÇ (v‚ÇÅ ‚à∑ œÅ)
interp-exp (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) œÅ =
  (interp-exp e‚ÇÅ œÅ) then
  Œª { (Bool true) ‚Üí interp-exp e‚ÇÇ œÅ
    ; (Bool false) ‚Üí interp-exp e‚ÇÉ œÅ
    ; (Int n) ‚Üí error }

interp-LIf : Exp ‚Üí Inputs ‚Üí Maybe Value
interp-LIf e s = run (interp-exp e []) s

----------------- Definition of LMonIf ----------------------------

data Atm : Set where
  Num : ‚Ñ§ ‚Üí Atm 
  Bool : ùîπ ‚Üí Atm 
  Var : Id ‚Üí Atm

data Mon : Set where
  Atom : Atm ‚Üí Mon
  Read : Mon
  Sub : Atm ‚Üí Atm ‚Üí Mon
  Eq : Atm ‚Üí Atm ‚Üí Mon
  Let : Mon ‚Üí Mon ‚Üí Mon
  If : Mon ‚Üí Mon ‚Üí Mon ‚Üí Mon

interp-atm : Atm ‚Üí Env Value ‚Üí Maybe Value
interp-atm (Num n) œÅ = just (Int n)
interp-atm (Bool b) œÅ = just (Bool b)
interp-atm (Var i) œÅ = nth œÅ i

interp-mon : Mon ‚Üí Env Value ‚Üí Reader Value
interp-mon (Atom atm) œÅ = try (interp-atm atm œÅ)
interp-mon Read œÅ = read-int Int
interp-mon (Sub a‚ÇÅ a‚ÇÇ) œÅ =
  (try (interp-atm a‚ÇÅ œÅ)) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí try (sub v‚ÇÅ v‚ÇÇ)
interp-mon (Eq a‚ÇÅ a‚ÇÇ) œÅ =
  (try (interp-atm a‚ÇÅ œÅ)) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí try (equal v‚ÇÅ v‚ÇÇ)
interp-mon (Let e‚ÇÅ e‚ÇÇ) œÅ =
  (interp-mon e‚ÇÅ œÅ) then
  Œª v‚ÇÅ ‚Üí interp-mon e‚ÇÇ (v‚ÇÅ ‚à∑ œÅ)
interp-mon (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) œÅ =
  (interp-mon e‚ÇÅ œÅ) then
  Œª { (Bool true) ‚Üí interp-mon e‚ÇÇ œÅ
    ; (Bool false) ‚Üí interp-mon e‚ÇÉ œÅ
    ; (Int n) ‚Üí error }

interp-LMonIf : Mon ‚Üí Inputs ‚Üí Maybe Value
interp-LMonIf m s = run (interp-mon m []) s

shift-atm : Atm ‚Üí ‚Ñï ‚Üí Atm
shift-atm (Num x) c = Num x
shift-atm (Bool b) c = Bool b
shift-atm (Var x) c = Var (shift-var x c)

shifts-atm : Atm ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Atm
shifts-atm (Num x) c n = Num x
shifts-atm (Bool b) c n = Bool b
shifts-atm (Var x) c n = Var (shifts-var x c n)

shift-mon : Mon ‚Üí ‚Ñï ‚Üí Mon
shift-mon (Atom atm) c = Atom (shift-atm atm c)
shift-mon Read c = Read
shift-mon (Sub a‚ÇÅ a‚ÇÇ) c = Sub (shift-atm a‚ÇÅ c) (shift-atm a‚ÇÇ c)
shift-mon (Eq a‚ÇÅ a‚ÇÇ) c = Eq (shift-atm a‚ÇÅ c) (shift-atm a‚ÇÇ c)
shift-mon (Let m‚ÇÅ m‚ÇÇ) c = Let (shift-mon m‚ÇÅ c) (shift-mon m‚ÇÇ (suc c))
shift-mon (If m‚ÇÅ m‚ÇÇ m‚ÇÉ) c = If (shift-mon m‚ÇÅ c) (shift-mon m‚ÇÇ c) (shift-mon m‚ÇÉ c)

down-atm : Atm ‚Üí ‚Ñï ‚Üí Atm
down-atm (Num x) c = Num x
down-atm (Bool b) c = Bool b
down-atm (Var x) c = Var (down-var x c)

down-mon : Mon ‚Üí ‚Ñï ‚Üí Mon
down-mon (Atom atm) c = Atom (down-atm atm c)
down-mon Read c = Read
down-mon (Sub a‚ÇÅ a‚ÇÇ) c = Sub (down-atm a‚ÇÅ c) (down-atm a‚ÇÇ c)
down-mon (Eq a‚ÇÅ a‚ÇÇ) c = Eq (down-atm a‚ÇÅ c) (down-atm a‚ÇÇ c)
down-mon (Let m‚ÇÅ m‚ÇÇ) c = Let (down-mon m‚ÇÅ c) (down-mon m‚ÇÇ (suc c))
down-mon (If m‚ÇÅ m‚ÇÇ m‚ÇÉ) c = If (down-mon m‚ÇÅ c) (down-mon m‚ÇÇ c) (down-mon m‚ÇÉ c)

----------------- Remove Complex Operands ----------------------------

data Atomic : Mon ‚Üí Set where
  atomic : ‚àÄ (a : Atm) ‚Üí Atomic (Atom a)

atomic? : (m : Mon) ‚Üí Dec (Atomic m)
atomic? (Atom a) = yes (atomic a)
atomic? Read = no Œª ()
atomic? (Sub a‚ÇÅ a‚ÇÇ) = no Œª ()
atomic? (Eq a‚ÇÅ a‚ÇÇ) = no Œª ()
atomic? (Let m‚ÇÅ m‚ÇÇ) = no Œª ()
atomic? (If m‚ÇÅ m‚ÇÇ m‚ÇÉ) = no Œª ()

-- The following isn't quite right because it doesn't shift things properly.
let-complex : Mon ‚Üí (Atm ‚Üí Mon) ‚Üí Mon
let-complex m body
    with atomic? m
... | yes (atomic a) = body a
... | no cmplx = Let m (body (Var 0))

rco : Exp ‚Üí Mon
rco (Num x) = Atom (Num x)
rco (Bool b) = Atom (Bool b)
rco Read = Read
rco (Sub e‚ÇÅ e‚ÇÇ)
    -- Fancy version:
    -- let-complex (rco e‚ÇÅ) 
    -- Œª a‚ÇÅ ‚Üí let-complex (shift-mon (rco e‚ÇÇ) 0) 
    -- Œª a‚ÇÇ ‚Üí Sub a‚ÇÅ a‚ÇÇ
    
    -- Complex version:
    with rco e‚ÇÅ | rco e‚ÇÇ
... | m‚ÇÅ | m‚ÇÇ
    with atomic? m‚ÇÅ | atomic? m‚ÇÇ
... | yes (atomic a‚ÇÅ) | yes (atomic a‚ÇÇ) =
      Sub a‚ÇÅ a‚ÇÇ
... | no cmplx‚ÇÅ | yes (atomic a‚ÇÇ) =
      Let (rco e‚ÇÅ) (Sub (Var zero) (shift-atm a‚ÇÇ 0))
... | yes (atomic a‚ÇÅ) | no cmplx‚ÇÇ =
      Let (rco e‚ÇÇ) (Sub (shift-atm a‚ÇÅ 0) (Var 0))
... | no cmplx‚ÇÅ | no cmplx‚ÇÇ = 
      Let m‚ÇÅ
        (Let (shift-mon m‚ÇÇ 0)
          (Sub (Var 1) (Var 0)))
          
   -- Simple version:
   -- Let (rco e‚ÇÅ)
   --   (Let (shift-mon (rco e‚ÇÇ) 0)
   --     (Sub (Var 1) (Var 0)))
rco (Eq e‚ÇÅ e‚ÇÇ) =
   Let (rco e‚ÇÅ)
    (Let (shift-mon (rco e‚ÇÇ) zero)
      (Eq (Var (suc (zero))) (Var zero)))
rco (Var i) = Atom (Var i)
rco (Let e‚ÇÅ e‚ÇÇ) = Let (rco e‚ÇÅ) (rco e‚ÇÇ)
rco (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) = If (rco e‚ÇÅ) (rco e‚ÇÇ) (rco e‚ÇÉ)

----------------- Definition of IL ----------------------------

data Imp-Exp : Set where
  Atom : Atm ‚Üí Imp-Exp
  Read : Imp-Exp
  Sub : Atm ‚Üí Atm ‚Üí Imp-Exp
  Eq : Atm ‚Üí Atm ‚Üí Imp-Exp
  Assign : Id ‚Üí Imp-Exp ‚Üí Imp-Exp ‚Üí Imp-Exp
  If : Imp-Exp ‚Üí Imp-Exp ‚Üí Imp-Exp ‚Üí Imp-Exp
  
data Imp-Prog : Set where
  Program : ‚Ñï ‚Üí Imp-Exp ‚Üí Imp-Prog

StateImp : Set
StateImp = Inputs √ó Env Value

data _‚ä¢_‚áì_‚ä£_ : StateImp ‚Üí Imp-Exp ‚Üí Value ‚Üí StateImp ‚Üí Set where
  ‚áìatom : ‚àÄ{s œÅ a v}
     ‚Üí interp-atm a œÅ ‚â° just v
     ‚Üí (s , œÅ) ‚ä¢ Atom a ‚áì v ‚ä£ (s , œÅ)
  ‚áìread : ‚àÄ{i f œÅ}
     ‚Üí ((i , f) , œÅ) ‚ä¢ Read ‚áì Int (f i) ‚ä£ ((suc i , f) , œÅ)
  ‚áìsub : ‚àÄ{s œÅ a‚ÇÅ a‚ÇÇ n‚ÇÅ n‚ÇÇ v}
     ‚Üí interp-atm a‚ÇÅ œÅ ‚â° just n‚ÇÅ
     ‚Üí interp-atm a‚ÇÇ œÅ ‚â° just n‚ÇÇ
     ‚Üí sub n‚ÇÅ n‚ÇÇ ‚â° just v
     ‚Üí (s , œÅ) ‚ä¢ Sub a‚ÇÅ a‚ÇÇ ‚áì v ‚ä£ (s , œÅ)
  ‚áìeq : ‚àÄ{s œÅ a‚ÇÅ a‚ÇÇ n‚ÇÅ n‚ÇÇ v}
     ‚Üí interp-atm a‚ÇÅ œÅ ‚â° just n‚ÇÅ
     ‚Üí interp-atm a‚ÇÇ œÅ ‚â° just n‚ÇÇ
     ‚Üí equal n‚ÇÅ n‚ÇÇ ‚â° just v
     ‚Üí (s , œÅ) ‚ä¢ Eq a‚ÇÅ a‚ÇÇ ‚áì v ‚ä£ (s , œÅ)
  ‚áìassign : ‚àÄ{sœÅ s‚Ä≤ œÅ‚Ä≤ sœÅ‚Ä≥ x e‚ÇÅ e‚ÇÇ n‚ÇÅ n‚ÇÇ}
     ‚Üí sœÅ ‚ä¢ e‚ÇÅ ‚áì n‚ÇÅ ‚ä£ (s‚Ä≤ , œÅ‚Ä≤)
     ‚Üí (s‚Ä≤ , update œÅ‚Ä≤ x n‚ÇÅ) ‚ä¢ e‚ÇÇ  ‚áì n‚ÇÇ ‚ä£ sœÅ‚Ä≥ 
     ‚Üí sœÅ ‚ä¢ Assign x e‚ÇÅ e‚ÇÇ ‚áì n‚ÇÇ ‚ä£ sœÅ‚Ä≥ 
  ‚áìif-true : ‚àÄ{sœÅ sœÅ‚Ä≤ sœÅ‚Ä≥ e‚ÇÅ e‚ÇÇ e‚ÇÉ v‚ÇÇ}
     ‚Üí sœÅ ‚ä¢ e‚ÇÅ ‚áì (Bool true) ‚ä£ sœÅ‚Ä≤ 
     ‚Üí sœÅ‚Ä≤ ‚ä¢ e‚ÇÇ ‚áì v‚ÇÇ ‚ä£ sœÅ‚Ä≥ 
     ‚Üí sœÅ ‚ä¢ If e‚ÇÅ e‚ÇÇ e‚ÇÉ ‚áì v‚ÇÇ ‚ä£ sœÅ‚Ä≥ 
  ‚áìif-false : ‚àÄ{sœÅ sœÅ‚Ä≤ sœÅ‚Ä≥ e‚ÇÅ e‚ÇÇ e‚ÇÉ v‚ÇÉ}
     ‚Üí sœÅ ‚ä¢ e‚ÇÅ ‚áì (Bool false) ‚ä£ sœÅ‚Ä≤ 
     ‚Üí sœÅ‚Ä≤ ‚ä¢ e‚ÇÉ ‚áì v‚ÇÉ ‚ä£ sœÅ‚Ä≥ 
     ‚Üí sœÅ ‚ä¢ If e‚ÇÅ e‚ÇÇ e‚ÇÉ ‚áì v‚ÇÉ ‚ä£ sœÅ‚Ä≥ 

interp-imp : Imp-Prog ‚Üí Inputs ‚Üí Value ‚Üí Set
interp-imp (Program n e) s v = Œ£[ s‚Ä≤ ‚àà StateImp ] (s , œÅ) ‚ä¢ e ‚áì v ‚ä£ s‚Ä≤
    where
    œÅ = replicate n (Int 0‚Ñ§)

----------------- Lift Locals ----------------------------

shifts-imp-exp : Imp-Exp ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Imp-Exp
shifts-imp-exp (Atom atm) c n = Atom (shifts-atm atm c n)
shifts-imp-exp Read c n = Read
shifts-imp-exp (Sub a‚ÇÅ a‚ÇÇ) c n =
    Sub (shifts-atm a‚ÇÅ c n) (shifts-atm a‚ÇÇ c n)
shifts-imp-exp (Eq a‚ÇÅ a‚ÇÇ) c n =
    Eq (shifts-atm a‚ÇÅ c n) (shifts-atm a‚ÇÇ c n)
shifts-imp-exp (Assign x e‚ÇÅ e‚ÇÇ) c n =
    Assign (shifts-var x c n) (shifts-imp-exp e‚ÇÅ c n) (shifts-imp-exp e‚ÇÇ c n)
shifts-imp-exp (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) c n =
    If (shifts-imp-exp e‚ÇÅ c n) (shifts-imp-exp e‚ÇÇ c n) (shifts-imp-exp e‚ÇÉ c n)

-- Lift Locals hoists all the Let's to the top, leaving in their place assignments.
--   let x = e‚ÇÅ in e‚ÇÇ
--   ==>
--   let x = 0 in { x := e‚Ä≤‚ÇÅ; e‚Ä≤‚ÇÇ }
--
--
--   Returns the number of variables bound by the let's around the expression:
--   let y‚ÇÅ=0,...,y·µ¢=0 in m
--   is represented as
--   i , m

lift-locals-mon : Mon ‚Üí ‚Ñï √ó Imp-Exp
lift-locals-mon (Atom a) = 0 , (Atom a)
lift-locals-mon Read = 0 , Read
lift-locals-mon (Sub a‚ÇÅ a‚ÇÇ) = 0 , (Sub a‚ÇÅ a‚ÇÇ)
lift-locals-mon (Eq a‚ÇÅ a‚ÇÇ) = 0 , (Eq a‚ÇÅ a‚ÇÇ)
lift-locals-mon (Let m‚ÇÅ m‚ÇÇ)
    with lift-locals-mon m‚ÇÅ
... | i , e‚ÇÅ
    with lift-locals-mon m‚ÇÇ
... | j , e‚ÇÇ
    = (suc (i + j)) , Assign (i + j) (shifts-imp-exp e‚ÇÅ 0 (suc j)) (shifts-imp-exp e‚ÇÇ j i)
lift-locals-mon (If m‚ÇÅ m‚ÇÇ m‚ÇÉ) 
    with lift-locals-mon m‚ÇÅ 
... | i , e‚ÇÅ
    with lift-locals-mon m‚ÇÇ 
... | j , e‚ÇÇ
    with lift-locals-mon m‚ÇÉ 
... | k , e‚ÇÉ
    =
    let e‚Ä≤‚ÇÅ = shifts-imp-exp e‚ÇÅ 0 (j + k) in
    let e‚Ä≤‚ÇÇ = shifts-imp-exp (shifts-imp-exp e‚ÇÇ 0 k) (k + j) i in
    let e‚Ä≤‚ÇÉ = shifts-imp-exp e‚ÇÉ k (i + j) in
    (i + j + k) , (If e‚Ä≤‚ÇÅ e‚Ä≤‚ÇÇ e‚Ä≤‚ÇÉ)
    
lift-locals : Mon ‚Üí Imp-Prog
lift-locals m
    with lift-locals-mon m
... | n , e = Program n e    

----------------- Definition of CVar ----------------------------

data CExp : Set where
  Atom : Atm ‚Üí CExp
  Read : CExp
  Sub : Atm ‚Üí Atm ‚Üí CExp
  Eq : Atm ‚Üí Atm ‚Üí CExp

data CStmt : Set where
  Return : CExp ‚Üí CStmt
  Assign : Id ‚Üí CExp ‚Üí CStmt ‚Üí CStmt
  IfEq : Atm ‚Üí Atm ‚Üí Id ‚Üí Id ‚Üí CStmt
  Goto : Id ‚Üí CStmt

CFG : Set
CFG = List CStmt

data CProg : Set where
  Program : ‚Ñï ‚Üí Id ‚Üí CFG ‚Üí CProg

interp-CExp : CExp ‚Üí Env Value ‚Üí Reader Value
interp-CExp (Atom atm) œÅ = try (interp-atm atm œÅ)
interp-CExp Read œÅ = read-int Int
interp-CExp (Sub a‚ÇÅ a‚ÇÇ) œÅ =
  (try (interp-atm a‚ÇÅ œÅ)) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí try (sub v‚ÇÅ v‚ÇÇ)
interp-CExp (Eq a‚ÇÅ a‚ÇÇ) œÅ =
  (try (interp-atm a‚ÇÅ œÅ)) then
  Œª v‚ÇÅ ‚Üí try (interp-atm a‚ÇÇ œÅ) then
  Œª v‚ÇÇ ‚Üí try (equal v‚ÇÅ v‚ÇÇ)

data _,_‚ä¢·∂ú_‚áì_‚ä£_ : StateImp ‚Üí CFG ‚Üí CStmt ‚Üí Value ‚Üí StateImp ‚Üí Set where
  ‚áìreturn : ‚àÄ{s s' œÅ G e v}
     ‚Üí interp-CExp e œÅ s ‚â° just (v , s')
     ‚Üí (s , œÅ) , G ‚ä¢·∂ú Return e ‚áì v ‚ä£ (s' , œÅ)
  ‚áìassign : ‚àÄ{s œÅ G s‚Ä≤ sœÅ‚Ä≥ x e‚ÇÅ e‚ÇÇ v‚ÇÅ v‚ÇÇ}
     ‚Üí interp-CExp e‚ÇÅ œÅ s ‚â° just (v‚ÇÅ , s‚Ä≤)
     ‚Üí (s‚Ä≤ , update œÅ x v‚ÇÅ) , G ‚ä¢·∂ú e‚ÇÇ  ‚áì v‚ÇÇ ‚ä£ sœÅ‚Ä≥ 
     ‚Üí (s , œÅ) , G ‚ä¢·∂ú Assign x e‚ÇÅ e‚ÇÇ ‚áì v‚ÇÇ ‚ä£ sœÅ‚Ä≥ 
  ‚áìif-true : ‚àÄ{s œÅ G s‚Ä≤ a‚ÇÅ a‚ÇÇ v‚ÇÅ v‚ÇÇ v t thn els}
     ‚Üí interp-atm a‚ÇÅ œÅ ‚â° just v‚ÇÅ
     ‚Üí interp-atm a‚ÇÇ œÅ ‚â° just v‚ÇÇ
     ‚Üí equal v‚ÇÅ v‚ÇÇ ‚â° just (Bool true)
     ‚Üí nth G thn ‚â° just t
     ‚Üí (s , œÅ) , G ‚ä¢·∂ú t ‚áì v ‚ä£ s‚Ä≤
     ‚Üí (s , œÅ) , G ‚ä¢·∂ú IfEq a‚ÇÅ a‚ÇÇ thn els ‚áì v ‚ä£ s‚Ä≤
  ‚áìif-false : ‚àÄ{s œÅ G s‚Ä≤ a‚ÇÅ a‚ÇÇ v‚ÇÅ v‚ÇÇ v t thn els}
     ‚Üí interp-atm a‚ÇÅ œÅ ‚â° just v‚ÇÅ
     ‚Üí interp-atm a‚ÇÇ œÅ ‚â° just v‚ÇÇ
     ‚Üí equal v‚ÇÅ v‚ÇÇ ‚â° just (Bool false)
     ‚Üí nth G els ‚â° just t
     ‚Üí (s , œÅ) , G ‚ä¢·∂ú t ‚áì v ‚ä£ s‚Ä≤
     ‚Üí (s , œÅ) , G ‚ä¢·∂ú IfEq a‚ÇÅ a‚ÇÇ thn els ‚áì v ‚ä£ s‚Ä≤
  ‚áìgoto : ‚àÄ {s G l v s‚Ä≤ t}
     ‚Üí nth G l ‚â° just t
     ‚Üí s , G ‚ä¢·∂ú t ‚áì v ‚ä£ s‚Ä≤ 
     ‚Üí s , G ‚ä¢·∂ú Goto l ‚áì v ‚ä£ s‚Ä≤ 

interp-prog : CProg ‚Üí Inputs ‚Üí Value ‚Üí Set
interp-prog (Program n l G) s v =
    Œ£[ s‚Ä≤ ‚àà StateImp ] (s , (replicate n (Int 0‚Ñ§))) , G ‚ä¢·∂ú Goto l ‚áì v ‚ä£ s‚Ä≤ 

----------------- Explicate Control ----------------------------

Build : Set ‚Üí Set
Build A = CFG ‚Üí A √ó CFG

retB : {A : Set} ‚Üí A ‚Üí Build A
retB a s = a , s

_thenB_ : {A B : Set} ‚Üí Build A ‚Üí (A ‚Üí Build B) ‚Üí Build B
(M thenB g) s
    with M s
... | (v , s') = g v s'

add-node : CStmt ‚Üí Build Id
add-node c B = length B , (B ++ [ c ])

explicate-assign : Id ‚Üí Imp-Exp ‚Üí CStmt ‚Üí Build CStmt
explicate-tail : Imp-Exp ‚Üí Build CStmt
explicate-pred : Imp-Exp ‚Üí CStmt ‚Üí CStmt ‚Üí Build CStmt

explicate-assign x (Atom a) c = retB (Assign x (Atom a) c)
explicate-assign x Read c = retB (Assign x Read c)
explicate-assign x (Sub a‚ÇÅ a‚ÇÇ) c = retB (Assign x (Sub a‚ÇÅ a‚ÇÇ) c)
explicate-assign x (Eq a‚ÇÅ a‚ÇÇ) c = retB (Assign x (Eq a‚ÇÅ a‚ÇÇ) c)
explicate-assign x (Assign y e‚ÇÅ e‚ÇÇ) c =
   (explicate-assign x e‚ÇÇ c) thenB
   Œª t‚ÇÇ ‚Üí explicate-assign y e‚ÇÅ t‚ÇÇ
explicate-assign y (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) c =
   add-node c thenB
   Œª l ‚Üí explicate-assign y e‚ÇÇ (Goto l) thenB
   Œª t‚ÇÇ ‚Üí explicate-assign y e‚ÇÉ (Goto l) thenB
   Œª t‚ÇÉ ‚Üí explicate-pred e‚ÇÅ t‚ÇÇ t‚ÇÉ
    
explicate-tail (Atom a) = retB (Return (Atom a))
explicate-tail Read = retB (Return Read)
explicate-tail (Sub a‚ÇÅ a‚ÇÇ) = retB (Return (Sub a‚ÇÅ a‚ÇÇ))
explicate-tail (Eq a‚ÇÅ a‚ÇÇ) = retB (Return (Eq a‚ÇÅ a‚ÇÇ))
explicate-tail (Assign x e‚ÇÅ e‚ÇÇ) =
    (explicate-tail e‚ÇÇ) thenB
    Œª t‚ÇÇ ‚Üí explicate-assign x e‚ÇÅ t‚ÇÇ
explicate-tail (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) =
  (explicate-tail e‚ÇÇ) thenB
  Œª t‚ÇÇ ‚Üí (explicate-tail e‚ÇÉ) thenB
  Œª t‚ÇÉ ‚Üí explicate-pred e‚ÇÅ t‚ÇÇ t‚ÇÉ

explicate-pred (Atom (Num x)) thn els = retB (Return (Atom (Num 0‚Ñ§)))
explicate-pred (Atom (Bool false)) thn els = retB els
explicate-pred (Atom (Bool true)) thn els = retB thn
explicate-pred (Atom (Var x)) thn els =
  add-node thn thenB
  Œª l‚ÇÅ ‚Üí add-node els thenB
  Œª l‚ÇÇ ‚Üí retB (IfEq (Var x) (Bool true) l‚ÇÅ l‚ÇÇ)
explicate-pred Read thn els = retB (Return (Atom (Num 0‚Ñ§)))
explicate-pred (Sub a‚ÇÅ a‚ÇÇ) thn els = retB (Return (Atom (Num 0‚Ñ§)))
explicate-pred (Eq a‚ÇÅ a‚ÇÇ) thn els =
  add-node thn thenB
  Œª lbl-thn ‚Üí add-node els thenB
  Œª lbl-els ‚Üí retB (IfEq a‚ÇÅ a‚ÇÇ lbl-thn lbl-els)
explicate-pred (Assign x e‚ÇÅ e‚ÇÇ) thn els =
  explicate-pred e‚ÇÇ thn els thenB
  Œª c ‚Üí explicate-assign x e‚ÇÅ c
explicate-pred (If e‚ÇÅ e‚ÇÇ e‚ÇÉ) thn els =
    add-node thn thenB
   Œª lbl-thn ‚Üí add-node els thenB
   Œª lbl-els ‚Üí explicate-pred e‚ÇÇ (Goto lbl-thn) (Goto lbl-els) thenB
   Œª t‚ÇÇ ‚Üí (explicate-pred e‚ÇÉ (Goto lbl-thn) (Goto lbl-els)) thenB
   Œª t‚ÇÉ ‚Üí explicate-pred e‚ÇÅ t‚ÇÇ t‚ÇÉ

explicate : Imp-Prog ‚Üí CProg
explicate (Program n e)
    with ((explicate-tail e) thenB
          (Œª t ‚Üí add-node t)) []
... | lbl , B = Program n lbl B

----------------- Definition of X86Var ----------------------------

data Arg : Set where
  Num : ‚Ñ§ ‚Üí Arg
  Bool : ùîπ ‚Üí Arg -- consider removing this and using 0/1 for booleans
  Var : Id ‚Üí Arg
  Reg : ‚Ñï ‚Üí Arg

data Dest : Set where
  Var : Id ‚Üí Dest
  Reg : ‚Ñï ‚Üí Dest

rax : ‚Ñï
rax = 0

data Inst : Set where
  MovQ : Arg ‚Üí Dest ‚Üí Inst
  SubQ : Arg ‚Üí Dest ‚Üí Inst
  CmpQ : Arg ‚Üí Arg ‚Üí Inst
  Jmp : Id ‚Üí Inst
  JmpEq : Id ‚Üí Inst
  ReadInt : Inst

Block : Set
Block = List Inst

data X86Var : Set where
  Program : ‚Ñï ‚Üí Id ‚Üí List Block ‚Üí X86Var

StateX86 : Set
StateX86 = Inputs √ó List Value √ó List Value -- input + registers + variables

interp-arg : Arg ‚Üí StateX86 ‚Üí Maybe Value
interp-arg (Num i) s = just (Int i)
interp-arg (Bool b) s = just (Bool b)
interp-arg (Var x) (inputs , regs , œÅ) = nth œÅ x
interp-arg (Reg x) (inputs , regs , œÅ) = nth regs x

interp-dest : Dest ‚Üí StateX86 ‚Üí Maybe Value
interp-dest (Var x) (inputs , regs , œÅ) = nth œÅ x
interp-dest (Reg x) (inputs , regs , œÅ) = nth regs x

write : Dest ‚Üí Value ‚Üí StateX86 ‚Üí StateX86
write (Var x) v (inputs , regs , œÅ) = (inputs , regs , update œÅ x v)
write (Reg x) v (inputs , regs , œÅ) = (inputs , update regs x v , œÅ)

-- The ùîπ says whether execution reached the end of the block (true) or halted early (false).
infix 4 _,_‚ä©_‚áì_,_
data _,_‚ä©_‚áì_,_ : StateX86 ‚Üí List Block ‚Üí List Inst ‚Üí StateX86 ‚Üí ùîπ ‚Üí Set 

-- The ùîπ says whether to fall through to the next instruction or not.
infix 4 _,_‚ä¢_‚áì_,_
data _,_‚ä¢_‚áì_,_ : StateX86 ‚Üí List Block ‚Üí Inst ‚Üí StateX86 ‚Üí ùîπ ‚Üí Set where
  ‚áìmovq : ‚àÄ{src}{dest}{s}{val}{B}
        ‚Üí interp-arg src s ‚â° just val
        ‚Üí s , B ‚ä¢ (MovQ src dest) ‚áì write dest val s , true
  ‚áìsubq : ‚àÄ{src}{dest}{s}{x y v}{B}
        ‚Üí interp-arg src s ‚â° just y
        ‚Üí interp-dest dest s ‚â° just x
        ‚Üí sub x y ‚â° just v
        ‚Üí s , B ‚ä¢ (SubQ src dest) ‚áì write dest v s , true
  ‚áìcmpq : ‚àÄ{a‚ÇÅ}{a‚ÇÇ}{s}{x y v}{B}
        ‚Üí interp-arg a‚ÇÅ s ‚â° just x
        ‚Üí interp-arg a‚ÇÇ s ‚â° just y
        ‚Üí equal x y ‚â° just v
        ‚Üí s , B ‚ä¢ (CmpQ a‚ÇÅ a‚ÇÇ) ‚áì write (Reg rax) v s , true   -- Using rax instead of EFLAGS
  ‚áìread : ‚àÄ{inputs inputs'}{regs}{œÅ}{v}{B}
        ‚Üí read-int Int inputs ‚â° just (v , inputs')
        ‚Üí (inputs , regs , œÅ) , B ‚ä¢ ReadInt ‚áì (inputs' , update regs rax v , œÅ) , true
  ‚áìjmp : ‚àÄ{s B l t s‚Ä≤ b}
        ‚Üí nth B l ‚â° just t
        ‚Üí s , B ‚ä© t ‚áì s‚Ä≤ , b
        ‚Üí s , B ‚ä¢ Jmp l ‚áì s‚Ä≤ , false
  ‚áìjmpeq-true : ‚àÄ{inputs regs œÅ B l t s‚Ä≤ b}
        ‚Üí nth regs rax ‚â° just (Bool true)
        ‚Üí nth B l ‚â° just t
        ‚Üí (inputs , regs , œÅ) , B ‚ä© t ‚áì s‚Ä≤ , b
        ‚Üí (inputs , regs , œÅ) , B ‚ä¢ JmpEq l ‚áì s‚Ä≤ , false
  ‚áìjmpeq-false : ‚àÄ{inputs regs œÅ B l}
        ‚Üí nth regs rax ‚â° just (Bool false)
        ‚Üí (inputs , regs , œÅ) , B ‚ä¢ JmpEq l ‚áì (inputs , regs , œÅ) , true

data _,_‚ä©_‚áì_,_ where
  ‚áìnull : ‚àÄ{s : StateX86}{B} ‚Üí s , B ‚ä© [] ‚áì s , true
  ‚áìcons : ‚àÄ{s s‚Ä≤ s‚Ä≥ : StateX86}{i}{is}{B}{b}
      ‚Üí s , B ‚ä¢ i ‚áì s‚Ä≤ , true
      ‚Üí s‚Ä≤ , B ‚ä© is ‚áì s‚Ä≥ , b
      ‚Üí s , B ‚ä© i ‚à∑ is ‚áì s‚Ä≥ , b
  ‚áìcons-halt : ‚àÄ{s s‚Ä≤ : StateX86}{i}{is}{B}
      ‚Üí s , B ‚ä¢ i ‚áì s‚Ä≤ , false
      ‚Üí s , B ‚ä© i ‚à∑ is ‚áì s‚Ä≤ , false
  
interp-x86-var : X86Var ‚Üí Inputs ‚Üí Value ‚Üí Set
interp-x86-var (Program n l B) inputs v =
  Œ£[ inputs' ‚àà Inputs ] Œ£[ regs ‚àà List Value ] Œ£[ œÅ ‚àà List Value ] Œ£[ b ‚àà ùîπ ]
  (inputs , [ Int 0‚Ñ§ ] , replicate n (Int 0‚Ñ§)) , B ‚ä¢ Jmp l ‚áì (inputs' , regs , œÅ) , b
  √ó nth regs 0 ‚â° just v

----------------- Instruction Selection ----------------------------

to-arg : Atm ‚Üí Arg
to-arg (Num n) = Num n
to-arg (Bool b) = Bool b
to-arg (Var x) = Var x

select-assign : CExp ‚Üí Dest ‚Üí List Inst
select-assign (Atom a) dest = MovQ (to-arg a) dest ‚à∑ []
select-assign Read dest = ReadInt ‚à∑ (MovQ (Reg rax) dest) ‚à∑ []
select-assign (Sub a‚ÇÅ a‚ÇÇ) dest =
  MovQ (to-arg a‚ÇÅ) (Reg rax) ‚à∑
  SubQ (to-arg a‚ÇÇ) (Reg rax) ‚à∑
  MovQ (Reg rax) dest ‚à∑ []
select-assign (Eq a‚ÇÅ a‚ÇÇ) dest =
  CmpQ (to-arg a‚ÇÅ) (to-arg a‚ÇÇ) ‚à∑
  MovQ (Reg rax) dest ‚à∑ []
  
select-stmt : CStmt ‚Üí List Inst
select-stmt (Return e) = select-assign e (Reg rax)
select-stmt (Assign x e c) = select-assign e (Var x) ++ select-stmt c
select-stmt (IfEq a‚ÇÅ a‚ÇÇ thn els) =
  CmpQ (to-arg a‚ÇÅ) (to-arg a‚ÇÇ) ‚à∑ JmpEq thn ‚à∑ Jmp els ‚à∑ []
select-stmt (Goto l) = Jmp l ‚à∑ [] 

select-inst : CProg ‚Üí X86Var
select-inst (Program n l B) =
  Program n l (map select-stmt B)

----------------- Compile ----------------------------

compile : Exp ‚Üí X86Var
compile e = (select-inst ‚àò explicate ‚àò lift-locals ‚àò rco) e

  
